<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>
<plugin
		name="WinkleWinkle_Extender_GUI_132"
		author="WinkleWinkle, Starling"
		id="3f498d929793c12cb70f5999"
		language="Lua"
		purpose="Search and Destroy GUI window"
		date_written="2017-09-15 18:30:00"
		requires="4.76"
		version="1.3"
		save_state="y"
		>
</plugin>

<aliases>
	<alias
		match="^xset reset gui$"
		script="reset_gui"
		name="xreset_gui_1"
		regexp="y"
		enabled="y"
		sequence="100"
		>
	</alias>

	<alias
		match="^xreset gui$"
		script="reset_gui"
		name="xreset_gui_2"
		regexp="y"
		enabled="y"
		sequence="100"
		>
	</alias>
</aliases>

<triggers>
	<trigger 
		match="CONGRATULATIONS! You have completed your campaign."
		script="do_trg_cp_complete"
		name="trg_cp_complete"
		enabled="y"
		sequence="100"
		>
	</trigger>
	
	<trigger 
		match="Campaign cleared."
		script="do_trg_cp_complete"
		name="trg_cp_quit"
		enabled="y"
		sequence="100"
		>
	</trigger>

<!-- v2 -->
<!-- GQ triggers -->	
<!-- set enabled="y" -->
	<trigger 
		match="^You still have to kill (?<qty>[0-9]) \* (?<mob>[^\(]+) \((?<where>.+?)(?<isdead> - Dead)?\)$"
		script="do_trg_gq_line"
		name="trg_gq_line"
		enabled="y" 
		regexp="y"
		sequence="10"
		>
	</trigger>
	
	<trigger
		match="^(?!You still have to kill).*$"
		script="do_trg_gq_line_end"
		name="trg_gq_line_end"
		enabled="n"
		regexp="y"
		sequence="10"
		>
	</trigger>
</triggers>

<script>
<![CDATA[

--[[
	Search and Destroy was originally written and released by WinkleWinkle (call it version 1.0.0)
	After Winkle left Aardwolf, Nokfah took over management and fixed some things. (call it version 1.1.0)
	Later on, Lunk took over management but got himself banned for unrelated reasons (call it version 1.2.0)
	
	Starling is the current developer as of 1 Jun 2017.  This version is numbered starting at 1.3.0

	Happy hunting, ninjas.
]]--

-- Required files
require "serialize"
require "tprint"
require "movewindow"
require "mw"

-- Initialize variables
local cpList = {}
local cpType = "none"

-- window dimensions
local win_height = 280
local win_width = 280
-- window position x,y coordinates
local pos_x = GetVariable("WinPosX") or 0
local pos_y = GetVariable("WinPosY") or 0
-- window dimensions min/max
local win_height_minimized = 45
local win_height_maximized = 280

local win_state = GetVariable("WinState") or "max"
local win_init = false

-- position where cp target list starts; line spacing between list items
local offset = 34
local line_spacing = 15

local hotspots = {}
local itemHotspots = {}
local win = "extender_gui_" .. GetPluginID ()	-- get a unique name, ensure not empty if outside plugin

local z_order_plugin = "462b665ecb569efbf261422f"
local USER_qq_report_channel = "gt" 			-- group tell

function create_win()

	if (win_init == false) then
		win_init = true
		WindowCreate (win, 0, 0, win_width, win_height, miniwin.pos_center_all, 0, ColourNameToRGB("black"))  -- create window
		
		-- move the window to the new location
		WindowPosition(win, pos_x, pos_y, 
			miniwin.pos_stretch_to_view, 
			miniwin.create_absolute_location)
			
		WindowShow(win, true)  -- show it 

		if (win_state == "min") then
			mouseup(0, "hsMinimize")
		end		
		
		WindowFont(win, "window_title", "Segoe", 9, true, false, false, false) -- define font
		WindowFont(win, "button", "Segoe", 10, true, false, false, false) -- define font
		WindowFont(win, "font", "Lucida Sans Unicode", 7, false, false, false, false) -- define font

		if (IsPluginInstalled(z_order_plugin) and GetPluginInfo(z_order_plugin, 17)) then
			CallPlugin(z_order_plugin, "registerMiniwindow", win)
		end		
		
		draw_window()	
	end
end

function draw_window()

	-- clear the window, which is the first step in updating it!
	WindowRectOp (win, miniwin.rect_fill, 0, 0, 0, 0, 0x000000)

	-- draw the window border
	WindowRectOp (win, 1, 0, 0, 0, 0, ColourNameToRGB("Silver"), 15)
	WindowRectOp (win, 1, 1, 16, -1, -1, 0x0000EE, 15)	-- the red perimeter line, because it's neat

	-- draw the title bar, which is also what we use to drag the window to new position
	WindowRectOp (win, 2, 0, 0, 0, 16 - win_height, 0x080808, 0x0000FF)
	WindowRectOp (win, 4, 0, 0, 0, 16 - win_height, 0xE0E0E0, 0x808080)
	
	-- draw the window title text and set its color
	WindowText (win, "window_title", 
				"Search & Destroy 1.3.2",	-- window title text
				5, 0, 0, 15 - win_height,	-- position of window title text
				0x80FFFF, 					-- colour (light yellow)
				false)						-- not unicode

	if (hotspots["hsDrag1"] == nil) then
		hotspots["hsDrag1"] = WindowAddHotspot(win, 
					"hsDrag1",  -- HS id
					0, 0, -80, 15 - win_height, -- rectangle
					"mouseover", 
					"cancelmouseover", 
					"mousedown",
					"cancelmousedown", 
					"mouseup", 
					"Drag to move",  -- tooltip text
					miniwin.cursor_both_arrow, 0)  -- 4-way arrows
			
		WindowDragHandler(win, "hsDrag1", "dragmove", "dragrelease", 0) 
	end

	-- GUI title bar buttons - help, front, back, min, max
	draw_button_2(win_width - 75, 0, 15, 16, "?", "hsHelp", "Show help", 4)			-- help
	draw_button_2(win_width - 60, 0, 15, 16, "f", "hsFront", "Bring to front", 4)	-- bring to front
	draw_button_2(win_width - 45, 0, 15, 16, "B", "hsBack", "Send to back", 3)		-- send to back
	draw_button_2(win_width - 30, 0, 15, 16, ".", "hsMinimize", "Minimize", 5)		-- minimize
	draw_button_2(win_width - 15, 0, 15, 16, "^", "hsMaximize", "Maximize", 3)		-- maximize

	-- Command buttons below title bar
	draw_button_1(5, 20, 30, 25, "xcp", "hsXcp", "XCP 1", 3)								-- xcp
	draw_button_1(38, 20, 30, 25, "go", "hsGo", "Go to room 1", 7)							-- GO
	draw_button_1(71, 20, 30, 25, "kk", "hsKill", "Kill target mob", 8)						-- KK
	draw_button_1(104, 20, 30, 25, "nx", "hsNext", "Left click = goto next\nRight click = goto prev", 7)-- NX
	draw_button_1(137, 20, 30, 25, "qs", "hsQS", "Quick-scan for target", 8)				-- QS
	draw_button_1(182, 20, 30, 25, "ref", "hsRefresh", "Refresh target list (cp check)", 6)	-- ref
	draw_button_1(212, 20, 30, 25, "hta", "hsHTA", "Abort hunt-trick", 5)					-- hta
	draw_button_1(242, 20, 30, 25, "clr", "hsClear", "Clear target list", 7)				-- clr
	
	if (win_state == "min") then
		return
	end
end

function draw_button_1(left, top, width, height, text, hsName, hint, textOffset)
	-- This function draws the command buttons located below the window title bar
	-- Draw the button background and set color
	WindowRectOp (win, 2, 	-- "2" means draw a solid shape (rectangle in this case)
		left, top, (left + width) - win_width, (top + height) - win_height, 
		0x000000)			-- button background color (black)
	
	-- Draw the button border/outline and set color
	WindowRectOp (win, 4,	-- "4" means draw an outlined shape
		left, top, (left + width) - win_width, (top + height) - win_height, 
		0xE0E0E0,			-- button's left and top borders (light grey)
		0x808080)			-- button's right and bottom borders (darker grey)
	
	-- Draw the button text and set color and default position.
	local dx
	if (textOffset == nil) then	textOffset = 5 end	-- set default text position
	if text == "xcp" then dx = 3 else dx = 3 end	-- adjust position of 'xcp' button since it's three letters instead of two,
	WindowText(win, "button", 
		text,				-- button text
		left + textOffset, top + dx, (left + width) - win_width, (top + height) - win_height,        -- rectangle
		0xE0E0E0,			-- button text colour (light grey)
		false)    			-- not Unicode

	-- Make the button clickable.  When mousing over button, change pointer to hand and show tooltip text.
	if (hotspots[hsName] == nil) then
		hotspots[hsName] = WindowAddHotspot(win, 
					hsName,	-- name/identifier of clickable area (referred to as a "hotspot")
					left, top, (left + width) - win_width, (top + height) - win_height,
					"mouseover", 
					"cancelmouseover", 
					"mousedown",
					"cancelmousedown", 
					"mouseup", 
					"" .. (hint or text),		-- tooltip text
					miniwin.cursor_hand, 0)		-- pointing hand shaped mouse pointer
	end
end

function draw_button_2(left, top, width, height, text, hsName, hint, textOffset)
	-- This function draws the buttons on the window title bar.

	-- Draw button background and set color
	WindowRectOp (win, 2, 	-- "2" means draw a solid colored square
		left, top, (left + width) - win_width, (top + height) - win_height, 
		0x000000)			-- button background color (black)
	
	-- Draw button border/outline and set colors
	WindowRectOp (win, 4,	-- "4" means draw an outline
		left, top, (left + width) - win_width, (top + height) - win_height, 
		0xE0E0E0,			-- button's left and top borders (light grey)
		0x808080)			-- button's right and bottom borders (darker grey)
	
	-- Add text to button and set color and default position
	if (textOffset == nil) then textOffset = 5 end
	WindowText(win, "button", 
		text,				-- button text
		left + textOffset, top + 0, (left + width) - win_width, (top + height) - win_height,
		0xE0E0E0,			-- button text color (light grey)
		false)				-- not Unicode
	
	-- Make the button clickable.  When mousing over button, change pointer to hand and show tooltip text.
	if (hotspots[hsName] == nil) then
		hotspots[hsName] = WindowAddHotspot(win, 
					hsName,	-- name/identifier of clickable area (referred to as a "hotspot")
					left, top, (left + width) - win_width, (top + height) - win_height,
					"mouseover", 
					"cancelmouseover", 
					"mousedown",
					"cancelmousedown", 
					"mouseup", 
					"" .. (hint or text),	-- tooltip text
					miniwin.cursor_hand, 0)	-- pointing hand shaped mouse pointer
	end
end

--clear the cp mob list
function clear_hotspots()
	for i,v in ipairs (itemHotspots) do
		--Note(i, v)
		WindowDeleteHotspot (win, v);
	end
	itemHotspots = {}
end

function write_items(mode)
	--Note(current_mode)
	--clear cp items
	clear_hotspots()
	if (win_state == "min") then
		return
	end

	if (current_mode() == "cp") then
		write_list_items(cpList)
	end
end

function gui_filter_cplist(list)
	
	local cptype_index = 0
	local cptype_list = {}
		for i,v in ipairs (list) do
		
		if (cpType == "none") then
			cptype_list = list
		elseif (cpType == "area") and (v.type == "area") then
			cptype_index = cptype_index + 1
			cptype_list[cptype_index] = v
		elseif (cpType == "room") and (v.type == "room") then
			cptype_index = cptype_index + 1
			cptype_list[cptype_index] = v
		end
	end
	cpList = cptype_list
end

function write_list_items(list)
	-- puts the campaign mob names into the list
	local index = 0
	
	for i,v in ipairs (list) do
		index = index + 1

		local qty = ""
		if (v.qty > 1) then
			qty = string.format("%s * ", v.qty)
		end
		
		local mobText = v.mob
		local deadFlag = false
		if (v.isDead ~= nil and v.isDead ~= "") then
			mobText = mobText .. " [Dead]"
			deadFlag = true
		end
		
		local place
		local color
		if (v.type == "area") then
			place = string.format("%s", v.areaId)
			if (deadFlag == false) then
				color = "0xF0F0F0"
			else
				color = "0x505050"
			end
		elseif (v.type == "room") then
			place = string.format("'%s' (%s) [%s-%s]", v.roomName, v.areaId, v.min, v.max)
			if (deadFlag == false) then
				color = "0xF0F0F0"
			else
				color = "0x505050"
			end
		else -- unknown
			place = string.format("'%s' is Unknown", v.roomName, v.areaId)
			if (deadFlag == false) then
				color = "0x0000E0"
			else
				color = "0x000040"
			end
		end
		
		local displayText = string.format("%s) %s%s - %s", index, qty, mobText, place)
		local tooltipText = "(" .. i .. ") " .. mobText .. " - " .. v.areaId
		--Note(displayText)

		width   = WindowTextWidth (win, "font", displayText)  -- width of text
		height  = WindowFontInfo (win, "font", 1)   -- height of the font
		ascent  = WindowFontInfo (win, "font", 2)   -- ascent (amount above the baseline)
		descent = WindowFontInfo (win, "font", 3)   -- descent (amount below the baseline)
		leading = WindowFontInfo (win, "font", 4)   -- leading (space above the highest letter)
		--Note(string.format("w:%s h:%s asc:%s desc:%s lead:%s", width, height, ascent, descent, leading)) 		
		
		WindowText (win, "font", 
					displayText,   -- text
					12, (tonumber(i) * line_spacing) + offset, 0, 0,        -- rectangle
					color,
					false)              -- not Unicode
				
		local hsLength = (5 + width) - win_width
		if (hsLength > 0) then hsLength = 0 end
		local hsHeight = ((tonumber(i) * line_spacing) + 12 + offset) - win_height
		if (hsHeight > 0) then hsHeight = 0 end

		--Note(string.format("%s %s %s %s", 5, (tonumber(i) * line_spacing) + offset, hsLength, hsHeight))

		local eventHandler
		if (current_mode() == "cp") then
			eventHandler = "mouseup_cp"
		end
		
		itemHotspots[#itemHotspots+1] = i
		WindowAddHotspot(win, 
						i,  -- HS id
						5, (tonumber(i) * line_spacing) + offset, hsLength, hsHeight, -- rectangle
						"mouseover", 
						"cancelmouseover", 
						"mousedown",
						"cancelmousedown", 
						eventHandler, 
						tooltipText,  -- tooltip text
						miniwin.cursor_hand, 0)  -- hand cursor
	end
end


function OnPluginBroadcast (msg, id, name, text)
	--Note(msg, text)
	-- Mapper Extender Plugin
	if (id == "b6eae87ccedd84f510b74715") then -- Mapper Extender
		if (msg == 669) then
			-- load serialize.save_simple data
			luastmt = "obj = " .. text
			assert (loadstring (luastmt or "")) ()
		
			cpList = obj
			draw_window()
			write_items("cp")
			Redraw()
		elseif (msg == 675) then
			cpType = text
			gui_filter_cplist(cpList)
			draw_window()
			write_items("cp")
			Redraw()
			--print("s&d GUI: " .. cpType)
		end
		
	elseif (id == "e50b1d08a0cfc0ee9c442001") then -- S&D
	end
end

function current_mode()
	if (#cpList > 0) then
		return "cp"
	else
		return "gq"
	end
end

-- When command button is clicked, this function send appropriate command
function mouseup(flags, hotspot_id)
	--Note(hotspot_id)
	if (hotspot_id == "hsXcp") then
		Execute("xcp 1")
		Execute("qs")
	elseif (hotspot_id == "hsGo") then
		Execute("go")
		Execute("qs")
	elseif (hotspot_id == "hsNext") then
		if bit.band(flags, 0x20) == 0 then	-- left click
			Execute("nx")
			Execute("qs")
		else								-- right click
			Execute("nx-")
			Execute("qs")
		end
	elseif (hotspot_id == "hsQS") then
		Execute("qs")
	elseif (hotspot_id == "hsKill") then
		Execute("kk")
	elseif (hotspot_id == "hsHTA") then
		Execute("hta")
	elseif (hotspot_id == "hsRefresh") then
		--if (current_mode() == "cp") then
		Execute("cp ch")
		--end
		mouseup(0, "hsMaximize")
	elseif (hotspot_id == "hsClear") then
		cpList = {}
		draw_window()
		write_items()
		Redraw()
	elseif (hotspot_id == "hsMinimize") then
		win_state = "min"
		win_height = win_height_minimized
		WindowResize(win, win_width, win_height, ColourNameToRGB("black"))
		draw_window()
		write_items()
		Redraw()
	elseif (hotspot_id == "hsMaximize") then
		win_state = "max"
		win_height = win_height_maximized
		WindowResize(win, win_width, win_height, ColourNameToRGB("black"))
		draw_window()
		write_items()
		Redraw()
	elseif (hotspot_id == "hsFront") then
		if (IsPluginInstalled(z_order_plugin) and GetPluginInfo(z_order_plugin, 17)) then
			CallPlugin(z_order_plugin, "boostMe", win)
		end
	elseif (hotspot_id == "hsBack") then
		if (IsPluginInstalled(z_order_plugin) and GetPluginInfo(z_order_plugin, 17)) then
			CallPlugin(z_order_plugin, "dropMe", win)
		end
	elseif (hotspot_id == "hsHelp") then
		Execute("ww help")
	end
end

function mouseup_cp(flags, hotspot_id)
	if (tonumber(hotspot_id) ~= nil) then
		Execute("xcp " .. hotspot_id)
	end
end

function do_trg_cp_complete(name, line, wildcards) 
	if (current_mode() == "cp") then
		mouseup(0, "hsClear") 
	end
end

------------ v2 -- GQ Items --------------
local do_trg_gq_line_index = 0

function do_trg_gq_line(name, line, wildcards) 
	--Note("Detected gq")
	cpList = {}
	--clear cp items
	clear_hotspots()
	
	EnableTrigger("trg_gq_line_end", true)

	if (do_trg_gq_line_index == 0) then
		draw_window()
	end

	do_trg_gq_line_index = do_trg_gq_line_index + 1
	
	local qty = ""
	if (tonumber(wildcards.qty) > 1) then
		qty = wildcards.qty .. " * "
	end
	
	local displayText = string.format("%s) %s%s %s - %s", do_trg_gq_line_index, qty, wildcards.mob, wildcards.isdead, wildcards.where)
	--Note(displayText)

	width   = WindowTextWidth (win, "font", displayText)  -- width of text
	height  = WindowFontInfo (win, "font", 1)   -- height of the font
	ascent  = WindowFontInfo (win, "font", 2)   -- ascent (amount above the baseline)
	descent = WindowFontInfo (win, "font", 3)   -- descent (amount below the baseline)
	leading = WindowFontInfo (win, "font", 4)   -- leading (space above the highest letter)
	--Note(string.format("w:%s h:%s asc:%s desc:%s lead:%s", width, height, ascent, descent, leading)) 		

	WindowText (win, "font", 
				displayText,   -- text
				5, (tonumber(do_trg_gq_line_index) * line_spacing) + offset, 0, 0,        -- rectangle
				0xFFFFFF,
				false)              -- not Unicode
					
end

-- Shuts down GQ functions after the GQ ends
function do_trg_gq_line_end(name, line, wildcards)
	EnableTrigger("trg_gq_line_end", false)
	do_trg_gq_line_index = 0
end


-- \\  WindowPosition("extender_gui_3f498d929793c12cb70f5999", 50, 50, miniwin.pos_stretch_to_view, miniwin.create_absolute_location);CallPlugin("462b665ecb569efbf261422f", "boostMe", "extender_gui_3f498d929793c12cb70f5999")

-- Before it was fixed, this function would bring the window back onto the screen after it had jumped off
function reset_gui(name, line, wildcards) 
	WindowPosition(win, 50, 50, 
	miniwin.pos_stretch_to_view, 
	miniwin.create_absolute_location)
	if (IsPluginInstalled(z_order_plugin) and GetPluginInfo(z_order_plugin, 17)) then
		CallPlugin(z_order_plugin, "boostMe", win)
	end                 
end

function dragmove(flags, hotspot_id)
	pos_x, pos_y = WindowInfo (win, 17) - (win_width / 2),
	WindowInfo (win, 18) - (win_height * 0.1)
	
	local max_x = GetInfo(281) - 100
	local max_y = GetInfo(280) - 60
  	
	-- Fixes the window jumping off the screen issue.
	if pos_x <= 1 then 
		pos_x = 1
	elseif pos_x >= max_x then 
		pos_x = max_x
	end
	
	if pos_y <= 1 then 
		pos_y = 1
	elseif pos_y >= max_y then 
		pos_y = max_y
	end

	-- move the window to the new location
	WindowPosition(win, pos_x, pos_y, 
                 miniwin.pos_stretch_to_view, 
                 miniwin.create_absolute_location)
    
end -- dragmove

function dragrelease(flags, hotspot_id)
--  print ("mouse drag release for " .. hotspot_id)
--  print ("released at position", WindowInfo (win, 17), WindowInfo (win, 18))

end -- dragrelease

function OnPluginClose ()
	WindowShow(win, false) -- hide window, refresh screen
end 

function OnPluginSaveState()
	SetVariable("WinPosX", pos_x)
	SetVariable("WinPosY", pos_y)
	SetVariable("WinState", win_state)
end


-- run it all
create_win()


	-- S&D PLUGIN ID'S:
	-- Mapper Extender			id="b6eae87ccedd84f510b74715"
	-- Mapper Extender GUI		id="3f498d929793c12cb70f5999"
	-- Search and Destroy		id="e50b1d08a0cfc0ee9c442001"

	-- OTHER RELEVANT PLUGINS
	-- Aardmush GMCP Mapper		id = "b6eae87ccedd84f510b74714"
	-- GMCP handler plugin		id = "3e7dedbe37e44942dd46d264"
	
]]>
</script>


<![CDATA[
<!--
BUG : Show UNKNOWNS [WW]

-->
]]>
</muclient>
