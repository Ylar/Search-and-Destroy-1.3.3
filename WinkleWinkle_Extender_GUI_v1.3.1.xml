<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>
<plugin
		name="WinkleWinkle_Extender_GUI_131"
		author="WinkleWinkle, Starling"
		id="3f498d929793c12cb70f5999"
		language="Lua"
		purpose="Search and Destroy GUI window"
		date_written="2017-06-01 17:00:00"
		requires="4.76"
		version="1.3"
		save_state="y"
		>
</plugin>

<aliases>
	<alias
		match="^xset reset gui$"
		script="reset_gui"
		name="ali_reset_gui"
		regexp="y"
		enabled="y"
		sequence="100"
		>
	</alias>
</aliases>


<triggers>
	<trigger 
		match="CONGRATULATIONS! You have completed your campaign."
		script="do_trg_cp_complete"
		name="trg_cp_complete"
		enabled="y"
		sequence="100"
		>
	</trigger>
	
	<trigger 
		match="Campaign cleared."
		script="do_trg_cp_complete"
		name="trg_cp_quit"
		enabled="y"
		sequence="100"
		>
	</trigger>

<!-- v2 -->
<!-- GQ triggers -->	
<!-- set enabled="y" -->
	<trigger 
		match="^You still have to kill (?<qty>[0-9]) \* (?<mob>[^\(]+) \((?<where>.+?)(?<isdead> - Dead)?\)$"
		script="do_trg_gq_line"
		name="trg_gq_line"
		enabled="y" 
		regexp="y"
		sequence="10"
		>
	</trigger>
	
	<trigger
		match="^(?!You still have to kill).*$"
		script="do_trg_gq_line_end"
		name="trg_gq_line_end"
		enabled="n"
		regexp="y"
		sequence="10"
		>
	</trigger>
</triggers>

<script>
<![CDATA[

--[[
	Search and Destroy was originally written and released by WinkleWinkle (call it version 1.0.0)
	After Winkle left Aardwolf, Nokfah took over management and fixed some things. (call it version 1.1.0)
	Later on, Lunk took over management but got himself banned for unrelated reasons (call it version 1.2.0)
	
	Starling is the current developer as of 1 Jun 2017.  This version is numbered starting at 1.3.0

	Happy hunting, ninjas.
]]--

-- Required files
require "serialize"
require "tprint"
require "movewindow"
require "mw"

-- Initialize variables
local cpList = {}

local win_height = 280
local min_height = 45
local max_height = 300

local win_width = 280
local win_state = GetVariable("WinState") or "max"
local win_init = false

local hotspots = {}
local itemHotspots = {}
local win = "extender_gui_" .. GetPluginID ()  -- get a unique name, ensure not empty if outside plugin

local z_order_plugin = "462b665ecb569efbf261422f"

local pos_x = GetVariable("WinPosX") or 0
local pos_y = GetVariable("WinPosY") or 0

local offset = 30
local line_spacing = 15

local USER_qq_report_channel = "gt" -- group tell

function create_win()

	if (win_init == false) then
		win_init = true
		WindowCreate (win, 0, 0, win_width, win_height, miniwin.pos_center_all, 0, ColourNameToRGB("black"))  -- create window
		
		-- move the window to the new location
		WindowPosition(win, pos_x, pos_y, 
			miniwin.pos_stretch_to_view, 
			miniwin.create_absolute_location)
			
		WindowShow(win, true)  -- show it 

		if (win_state == "min") then
			mouseup(0, "hsMinimize")
		end		
		
		WindowFont(win, "button", "Lucida Sans Unicode", 8, true, false, false, false) -- define font
		WindowFont(win, "font", "Lucida Sans Unicode", 7, false, false, false, false) -- define font

		if (IsPluginInstalled(z_order_plugin) and GetPluginInfo(z_order_plugin, 17)) then
			CallPlugin(z_order_plugin, "registerMiniwindow", win)
		end		
		
		draw_window()	
	end
end

function draw_window()

	-- clear the window, which is the first step in updating it!
	WindowRectOp (win, miniwin.rect_fill, 0, 0, 0, 0, ColourNameToRGB("Black"))

	-- draw the window border
	WindowRectOp (win, 1, 0, 0, 0, 0, ColourNameToRGB("Silver"), 15)
	WindowRectOp (win, 1, 1, 16, -1, -1, 0x0000EE, 15)	-- the red perimeter line, because it's neat

	-- draw the title bar, which is also what we use to drag the window to new position
	WindowRectOp (win, 2, 0, 0, 0, 16 - win_height, 0x080808, 0x0000FF)
	WindowRectOp (win, 4, 0, 0, 0, 16 - win_height, 0xE0E0E0, 0x808080)
	
	-- draw the window title text and set its color
	WindowText (win, "button", 
				"Search & Destroy 1.3.1",	-- window title text
				3, -1, 0, 12 - win_height,	-- position of window title text
				0x80FFFF, 					-- colour (light yellow)
				false)						-- not unicode

	if (hotspots["hsDrag1"] == nil) then
		hotspots["hsDrag1"] = WindowAddHotspot(win, 
					"hsDrag1",  -- HS id
					0, 0, -80, 15 - win_height, -- rectangle
					"mouseover", 
					"cancelmouseover", 
					"mousedown",
					"cancelmousedown", 
					"mouseup", 
					"Drag to move",  -- tooltip text
					miniwin.cursor_both_arrow, 0)  -- 4-way arrows
			
		WindowDragHandler(win, "hsDrag1", "dragmove", "dragrelease", 0) 
	end

	-- window system (title bar) buttons - help, front, back, min, max
	draw_button_2(win_width - 75, 0, 15, 16, "?", "hsHelp", "Show help", 4)			-- help
	draw_button_2(win_width - 60, 0, 15, 16, "f", "hsFront", "Bring to front", 4)	-- bring to front
	draw_button_2(win_width - 45, 0, 15, 16, "B", "hsBack", "Send to back", 3)		-- send to back
	draw_button_2(win_width - 30, 0, 15, 16, ".", "hsMinimize", "Minimize", 5)		-- minimize
	draw_button_2(win_width - 15, 0, 15, 16, "^", "hsMaximize", "Maximize", 3)		-- maximize

	-- Command buttons below title bar
	draw_button(5, 19, 30, 21, "xcp", "hsXcp", "XCP 1", 3)							-- xcp
	draw_button(38, 19, 30, 21, "GO", "hsGo", "Go to room 1", 6)					-- GO
	draw_button(71, 19, 30, 21, "NX", "hsNext", "Next room", 6)						-- NX
	draw_button(104, 19, 30, 21, "Qk", "hsKill", "Kill target mob", 6)				-- Qk
	draw_button(137, 19, 30, 21, "QS", "hsQS", "Quick-scan for target", 6)			-- QS
	draw_button(182, 19, 30, 21, "ref", "hsRefresh", "Refresh CP/GQ list", 5)		-- ref
	draw_button(212, 19, 30, 21, "hta", "hsHTA", "Abort hunt-trick", 5)				-- hta
	draw_button(242, 19, 30, 21, "clr", "hsClear", "Clear CP/GQ list", 6)			-- clr
	
	if (win_state == "min") then
		return
	end
end

function draw_button(left, top, width, height, text, hsName, hint, textOffset)
	-- This function draws the command buttons located below the window title bar
	-- Draw the button background and set color
	WindowRectOp (win, 2, 	-- "2" means draw a solid shape (rectangle in this case)
		left, top, (left + width) - win_width, (top + height) - win_height, 
		0x000000)			-- button background color (black)
	
	-- Draw the button border/outline and set color
	WindowRectOp (win, 4,	-- "4" means draw an outlined shape
		left, top, (left + width) - win_width, (top + height) - win_height, 
		0xE0E0E0,			-- button's left and top borders (light grey)
		0x808080)			-- button's right and bottom borders (darker grey)
	
	-- Draw the button text and set color and default position.
	-- The first "if" sets the default text position
	-- The second "if" adjusts the centering of the "xcp" button, needed because it's three letters instead of two.
	-- There's probably a better way to do it, but this works.
	local dx
	if (textOffset == nil) then	textOffset = 5 end
	if text == "xcp" then dx = 1 else dx = 2 end
	WindowText(win, "button", 
		text,				-- button text
		left + textOffset, top + dx, (left + width) - win_width, (top + height) - win_height,        -- rectangle
		0xE0E0E0,			-- button text colour (light grey)
		false)    			-- not Unicode

	-- Make the button clickable.  When mousing over button, change pointer to hand and show tooltip text.
	if (hotspots[hsName] == nil) then
		hotspots[hsName] = WindowAddHotspot(win, 
					hsName,	-- name/identifier of clickable area (referred to as a "hotspot")
					left, top, (left + width) - win_width, (top + height) - win_height,
					"mouseover", 
					"cancelmouseover", 
					"mousedown",
					"cancelmousedown", 
					"mouseup", 
					"" .. (hint or text),		-- tooltip text
					miniwin.cursor_hand, 0)		-- pointing hand shaped mouse pointer
	end
end

function draw_button_2(left, top, width, height, text, hsName, hint, textOffset)
	-- This function draws the buttons on the window title bar.

	-- Draw button background and set color
	WindowRectOp (win, 2, 	-- "2" means draw a solid colored square
		left, top, (left + width) - win_width, (top + height) - win_height, 
		0x000000)			-- button background color (black)
	
	-- Draw button border/outline and set colors
	WindowRectOp (win, 4,	-- "4" means draw an outline
		left, top, (left + width) - win_width, (top + height) - win_height, 
		0xE0E0E0,			-- button's left and top borders (light grey)
		0x808080)			-- button's right and bottom borders (darker grey)
	
	-- Add text to button and set color and default position
	if (textOffset == nil) then textOffset = 5 end
	WindowText(win, "button", 
		text,				-- button text
		left + textOffset, top + 0, (left + width) - win_width, (top + height) - win_height,
		0xE0E0E0,			-- button text color (light grey)
		false)				-- not Unicode
	
	-- Make the button clickable.  When mousing over button, change pointer to hand and show tooltip text.
	if (hotspots[hsName] == nil) then
		hotspots[hsName] = WindowAddHotspot(win, 
					hsName,	-- name/identifier of clickable area (referred to as a "hotspot")
					left, top, (left + width) - win_width, (top + height) - win_height,
					"mouseover", 
					"cancelmouseover", 
					"mousedown",
					"cancelmousedown", 
					"mouseup", 
					"" .. (hint or text),	-- tooltip text
					miniwin.cursor_hand, 0)	-- pointing hand shaped mouse pointer
	end
end

--clear the cp mob list
function clear_hotspots()
	for key, value in ipairs(itemHotspots) do
		--Note(key, value)
		WindowDeleteHotspot (win, value);
	end
	itemHotspots = {}
end

function write_items(mode)
	--Note(current_mode)
	--clear cp items
	clear_hotspots()
	if (win_state == "min") then
		return
	end

	if (current_mode() == "cp") then
		write_list_items(cpList)
	end
end

function write_list_items(list)
	-- puts the campaign mob names into the list
	local index = 0
	
	for key, value in ipairs(list) do
		index = index + 1

		local qty = ""
		if (value.qty > 1) then
			qty = string.format("%s * ", value.qty)
		end
		
		local mobText = value.mob
		local deadFlag = false
		if (value.isDead ~= nil and value.isDead ~= "") then
			mobText = mobText .. " [Dead]"
			deadFlag = true
		end
		
		local place
		local color
		if (value.type == "area") then
			place = string.format("(%s)", value.areaId)
			if (deadFlag == false) then
				color = "white"
			else
				color = "DimGray"
			end
		elseif (value.type == "room") then
			place = string.format("'%s' (%s) [%s-%s]", value.roomName, value.areaId, value.min, value.max)
			if (deadFlag == false) then
				color = "LightBlue"
			else
				color = "DimGray"
			end
		else -- unknown
			place = string.format("'%s' is Unknown", value.roomName, value.areaId)
			if (deadFlag == false) then
				color = "Crimson"
			else
				color = "DarkRed"
			end
		end
		
		local displayText = string.format("%s) %s%s - %s", index, qty, mobText, place)
		--Note(displayText)

		width   = WindowTextWidth (win, "font", displayText)  -- width of text
		height  = WindowFontInfo (win, "font", 1)   -- height of the font
		ascent  = WindowFontInfo (win, "font", 2)   -- ascent (amount above the baseline)
		descent = WindowFontInfo (win, "font", 3)   -- descent (amount below the baseline)
		leading = WindowFontInfo (win, "font", 4)   -- leading (space above the highest letter)
		--Note(string.format("w:%s h:%s asc:%s desc:%s lead:%s", width, height, ascent, descent, leading)) 		
		
		WindowText (win, "font", 
					displayText,   -- text
					12, (tonumber(key) * line_spacing) + offset, 0, 0,        -- rectangle
					ColourNameToRGB (color),
					false)              -- not Unicode
				
		local hsLength = (5 + width) - win_width
		if (hsLength > 0) then hsLength = 0 end
		local hsHeight = ((tonumber(key) * line_spacing) + 12 + offset) - win_height
		if (hsHeight > 0) then hsHeight = 0 end

		--Note(string.format("%s %s %s %s", 5, (tonumber(key) * line_spacing) + offset, hsLength, hsHeight))

		local eventHandler
		if (current_mode() == "cp") then
			eventHandler = "mouseup_cp"
		end
		
		itemHotspots[#itemHotspots+1] = key
		WindowAddHotspot(win, 
						key,  -- HS id
						5, (tonumber(key) * line_spacing) + offset, hsLength, hsHeight, -- rectangle
						"mouseover", 
						"cancelmouseover", 
						"mousedown",
						"cancelmousedown", 
						eventHandler, 
						"Click to perform CP Item",  -- tooltip text
						miniwin.cursor_hand, 0)  -- hand cursor
	end
end


function OnPluginBroadcast (msg, id, name, text)
	--Note(msg, text)
	-- Mapper Extender Plugin
	if (id == "b6eae87ccedd84f510b74715") then -- Mapper Extender
		if (msg == 669) then
			-- load serialize.save_simple data
			luastmt = "obj = " .. text
			assert (loadstring (luastmt or "")) ()
		
			cpList = obj
			draw_window()
			write_items("cp")
			Redraw()
		end
	elseif (id == "e50b1d08a0cfc0ee9c442001") then -- S&D
	end
end

function current_mode()
	if (#cpList > 0) then
		return "cp"
	else
		return "gq"
	end
end

-- When command button is clicked, this function send appropriate command
function mouseup(flags, hotspot_id)
	--Note(hotspot_id)
	if (hotspot_id == "hsXcp") then
		Execute("xcp 1")
		Execute("qs")
	elseif (hotspot_id == "hsGo") then
		Execute("go")
		Execute("qs")
	elseif (hotspot_id == "hsNext") then
		Execute("nx")
		Execute("qs")
	elseif (hotspot_id == "hsQS") then
		Execute("qs")
	elseif (hotspot_id == "hsKill") then
			Execute("quickkill")
	elseif (hotspot_id == "hsHTA") then
		Execute("hta")
	elseif (hotspot_id == "hsRefresh") then
		if (current_mode() == "cp") then
			Execute("cp ch")
		end
		mouseup(0, "hsMaximize")
	elseif (hotspot_id == "hsClear") then
		cpList = {}
		draw_window()
		write_items()
		Redraw()
	elseif (hotspot_id == "hsMinimize") then
		win_state = "min"
		win_height = min_height
		WindowResize(win, win_width, win_height, ColourNameToRGB("black"))
		draw_window()
		write_items()
		Redraw()
	elseif (hotspot_id == "hsMaximize") then
		win_state = "max"
		win_height = max_height
		WindowResize(win, win_width, win_height, ColourNameToRGB("black"))
		draw_window()
		write_items()
		Redraw()
	elseif (hotspot_id == "hsFront") then
		if (IsPluginInstalled(z_order_plugin) and GetPluginInfo(z_order_plugin, 17)) then
			CallPlugin(z_order_plugin, "boostMe", win)
		end
	elseif (hotspot_id == "hsBack") then
		if (IsPluginInstalled(z_order_plugin) and GetPluginInfo(z_order_plugin, 17)) then
			CallPlugin(z_order_plugin, "dropMe", win)
		end
	elseif (hotspot_id == "hsHelp") then
		Execute("ww help")
	end
end

function mouseup_cp(flags, hotspot_id)
	if (tonumber(hotspot_id) ~= nil) then
		Execute("xcp " .. hotspot_id)
	end
end

function do_trg_cp_complete(name, line, wildcards) 
	if (current_mode() == "cp") then
		mouseup(0, "hsClear") 
	end
end

------------ v2 -- GQ Items --------------
local do_trg_gq_line_index = 0

function do_trg_gq_line(name, line, wildcards) 
	--Note("Detected gq")
	cpList = {}
	--clear cp items
	clear_hotspots()
	
	EnableTrigger("trg_gq_line_end", true)

	if (do_trg_gq_line_index == 0) then
		draw_window()
	end

	do_trg_gq_line_index = do_trg_gq_line_index + 1
	
	local qty = ""
	if (tonumber(wildcards.qty) > 1) then
		qty = wildcards.qty .. " * "
	end
	
	local displayText = string.format("%s) %s%s %s - %s", do_trg_gq_line_index, qty, wildcards.mob, wildcards.isdead, wildcards.where)
	--Note(displayText)

	width   = WindowTextWidth (win, "font", displayText)  -- width of text
	height  = WindowFontInfo (win, "font", 1)   -- height of the font
	ascent  = WindowFontInfo (win, "font", 2)   -- ascent (amount above the baseline)
	descent = WindowFontInfo (win, "font", 3)   -- descent (amount below the baseline)
	leading = WindowFontInfo (win, "font", 4)   -- leading (space above the highest letter)
	--Note(string.format("w:%s h:%s asc:%s desc:%s lead:%s", width, height, ascent, descent, leading)) 		

	WindowText (win, "font", 
				displayText,   -- text
				5, (tonumber(do_trg_gq_line_index) * line_spacing) + offset, 0, 0,        -- rectangle
				ColourNameToRGB ("snow"),
				false)              -- not Unicode
					
end

-- Shuts down GQ functions after the GQ ends
function do_trg_gq_line_end(name, line, wildcards)
	EnableTrigger("trg_gq_line_end", false)
	do_trg_gq_line_index = 0
end


-- \\  WindowPosition("extender_gui_3f498d929793c12cb70f5999", 50, 50, miniwin.pos_stretch_to_view, miniwin.create_absolute_location);CallPlugin("462b665ecb569efbf261422f", "boostMe", "extender_gui_3f498d929793c12cb70f5999")

-- Before it was fixed, this function would bring the window back onto the screen after it had jumped off
function reset_gui(name, line, wildcards) 
	WindowPosition(win, 50, 50, 
	miniwin.pos_stretch_to_view, 
	miniwin.create_absolute_location)
	if (IsPluginInstalled(z_order_plugin) and GetPluginInfo(z_order_plugin, 17)) then
		CallPlugin(z_order_plugin, "boostMe", win)
	end                 
end

function dragmove(flags, hotspot_id)
	pos_x, pos_y = WindowInfo (win, 17) - (win_width / 2),
	WindowInfo (win, 18) - (win_height * 0.1)
	
	local max_x = GetInfo(281) - 100
	local max_y = GetInfo(280) - 60
  	
	-- Fixes the window jumping off the screen issue.  Hooray!
	if pos_x <= 1 then 
		pos_x = 1
	elseif pos_x >= max_x then 
		pos_x = max_x
	end
	
	if pos_y <= 1 then 
		pos_y = 1
	elseif pos_y >= max_y then 
		pos_y = max_y
	end

	-- move the window to the new location
	WindowPosition(win, pos_x, pos_y, 
                 miniwin.pos_stretch_to_view, 
                 miniwin.create_absolute_location)
    
end -- dragmove

function dragrelease(flags, hotspot_id)
--  print ("mouse drag release for " .. hotspot_id)
--  print ("released at position", WindowInfo (win, 17), WindowInfo (win, 18))

end -- dragrelease

function OnPluginClose ()
	WindowShow(win, false) -- hide window, refresh screen
end 

function OnPluginSaveState()
	SetVariable("WinPosX", pos_x)
	SetVariable("WinPosY", pos_y)
	SetVariable("WinState", win_state)
end


-- run it all
create_win()

]]>
</script>


<![CDATA[
<!--
BUG : Show UNKNOWNS [WW]

-->
]]>
</muclient>
