<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<muclient>
<plugin
   name="WinkleWinkle_Mapper_Extender_131"
   author="WinkleWinkle, Starling"
   id="b6eae87ccedd84f510b74715"
   language="Lua"
   purpose="Extends mapper functionality"
   date_written="2017-06-01 17:00:00"
   requires="4.76"
   version="1.3"
   save_state="y"
   >

<description trim="n">
<![CDATA[

MAPPER EXTENDER USAGE:

===== SHOW THIS HELP =============>
>    extender help
        - shows only this help
>    ww help
        - all winklewinkle(tm) plugins show help

===== RUNNING ====================>
>   xrunto [areaname]
        - Runs you via mapper goto/walkto to the first room you discovered in that area
		
>   xrt [areaname]
        - Same as "xrunto"

>   xset mark
        - Sets the current room you are in to be the "first" room of that area	

>   xset speed
        - Toggles the use of mapper goto/walkto for all movement commands
		
>   xset speed <walk|run>
        - changes the use of mapper goto/walkto for all movement commands

>   xmapper move <roomid>		
        - uses set movement speed to move to the specified room id

>   xmapper move <roomid> <walk|run>
        - uses a temporary movement speed to move to the specified room id
		
===== SEARCHING ==================>
>   xm [roomname]	
        - Lists and numbers rooms that match the [roomname] exactly, and then partial matches in the current area
		
>   xmall [roomname]
        - Lists and numbers rooms that match the [roomname] exactly, and then partial matches in all areas
		
===== ROOMS ======================>
>   go [index]
        - Will run you with mapper goto/walkto to the first room in a numbered room list
		
>   go
        - The same as typing "go 1"
		
>   nx
        - Will run you to the next numbered room, "go" then "nx" would be the same as typing "go 1" then "go 2"
		
===== CAMPAIGNS ==================>
>   xcp	
        - Lists all active campaign mobs in a numbered list (see xcp [index])
		
>   xcp [index]
        - Area CP runs you to the area of that CP item and does a Quick-Where on your mob. Type "go [index]" after this to go to the first known room found (if any)
        - Room CP lists all known rooms that exactly match your CP room name. Type "go [index]" to run to the right room (if any).

===== NOTES ======================>
>   roomnote
        - Lists all mapper notes for the current room (if any).
		
>   roomnote area
        - Lists all mapper notes for the current area (if any). Useful for mazes

===== SETTINGS ======================>
>   xset pk
        - Toggles the display of PK flag in room searches

>   xset vidblain
        - Toggles a hack that will allow you to speedwalk to vidblain areas if you do not have a portal to use
		
>	xset reset gui
		- Will reset the X, Y and Z position of the Extender GUI

===== TO CREATE A CEXIT / MAP A PORTAL ==========>

http://code.google.com/p/aardwolf-scriptalicious/wiki/MapperHelp
		
]]>
</description>

</plugin>

<!--  Timers  -->

<timers>
	<timer
		name="tim_init_plugin"
		script="init_plugin"
		enabled="y"
		second="1"
		>
	</timer>
	
	<timer
		name="execute_in_area_timer"
		script="execute_in_area_tick"
		enabled="n"
		second="0.25"
		>
	</timer>
</timers>


<!--  finding aliases -->
<aliases>
	<!-- debug -->
	<alias
		match="^ext debug$"
		script="ext_debug"
		name="ali_toggle_debug"
		regexp="y"
		enabled="y"
		sequence="100"
		>
	</alias>

	<alias 
		match="^(?:ww|extender) help$"
		enabled="y"
		sequence="100"
		send_to="12"
		regexp="y"
		keep_evaluating="y"		
		>
		<send>ColourNote("MediumSeaGreen", "", GetPluginInfo (GetPluginID (), 3))</send>
	</alias>

	<!-- Settings -->
	<alias
		match="^xset pk$"
		script="xset_pk"
		name="ali_set_pk"
		regexp="y"
		enabled="y"
		sequence="100"
		>
	</alias>

	<alias 
		match="^xset mark$"
		script="xset_to_mark"
		enabled="y"
		sequence="100"
		regexp="y"
		>
	</alias>

	<alias 
		match="^xset vidblain$"
		script="set_check_vidblain"
		enabled="y"
		sequence="99"
		regexp="y"
		>
	</alias>

	<alias
		match="^xru?n?to? (.+)$"
		script="xrun_to"
		enabled="y"
		sequence="100"
		regexp="y"
		>
	</alias>

	<alias
		match="^xm(?:\ {(?<mob>[^\}]+)\})? (?<loc>.+)$"
		script="map_area"
		enabled="y"
		sequence="100"
		regexp="y"
		>
	</alias>

	<alias
		match="^xmal?l?(?:\ {(?<mob>[^\}]+)\})? (?<loc>.+)$"
		script="map_area_all"
		enabled="y"
		sequence="99"
		regexp="y"
		keep_evaluating="n"
		>
	</alias>

	<alias 
		match="^(?<cmd>cp|ca|cam|camp|campa|campai|campaig|campaign) (?<param>c|ch|che|chec|check)$"
		script="xcp_check"
		enabled="y"
		sequence="5"
		regexp="y"
		>
	</alias>
	
	<alias 
		match="^(?<cmd>xcp) ?(?<param>c|ch|che|chec|check|test)?$"
		script="xcp_check"
		enabled="y"
		sequence="6"
		regexp="y"
		>
	</alias>

	<alias 
		match="^got?o?( (?<id>.+))?$"
		script="goto_number"
		enabled="y"
		sequence="100"
		regexp="y"
		>
	</alias>

	<alias 
		match="^nx$"
		script="goto_next"
		enabled="y"
		sequence="100"
		regexp="y"
		>
	</alias>

	<alias 
		match="^(xcp|cp|ca|cam|camp|campa|campaign) (?<index>[0-9]+)$"
		script="goto_cp"
		enabled="y"
		sequence="100"
		regexp="y"
		>
	</alias>

	<!-- speed -->
	<alias
		match="^xset speed ?(?<speed>run|walk)?$"
		script="set_speed"
		enabled="y"
		sequence="100"
		regexp="y"
		>
	</alias>
	
	<alias
		match="^xma?p?p?e?r? move (?<roomid>[0-9]+) ?(?<speed>run|walk)?$"
		script="move_trigger"
		enabled="y"
		sequence="95"
		regexp="y"
		>
	</alias>
	
	<!-- roomnotes -->
	<alias
		match="^r(?:oomnote|n)$"
		script="room_note"
		enabled="y"
		sequence="100"
		regexp="y"
		>
	</alias>

	<alias
		match="^r(?:oomnote|n) a(?:rea)?(?: (?<areaid>.+))?$"
		script="room_note_area"
		enabled="y"
		sequence="99"
		regexp="y"
		>
	</alias>

 	<alias
		match="^xmapper purge room$"
		script="map_purgeroom"
		enabled="y"
		sequence="100"
		regexp="y"
		>
	</alias>

	<!-- Sql Execution -->
	<alias 
		match="^runsql (?<sql>.+)$"
		script="RunSql"
		name="runsql"
		enabled="y"
		sequence="1"
		regexp="y"
		>
	</alias>

    <alias
		match="^execsql (?<sql>.+)$"
		script="ExecSql"
		name="execsql"
    	enabled="y"
    	sequence="1"
    	regexp="y"
		>
    </alias>
</aliases>


<triggers>
	<trigger
		match="^.+ tells you \'Good luck in your campaign\!\'$"
		name="trg_cp_request"
		enabled="y"
		regexp="y"
		sequence="100"
		send_to="12"
		>
		<send>Execute("cp ch")</send>
	</trigger>

	<trigger
		match="Congratulations, that was one of your CAMPAIGN mobs!"
		name="trg_cp_mob_dead"
		enabled="y"
		sequence="100"
		send_to="12"
		>
		<send>Execute("cp ch")</send>
	</trigger>

	<trigger
		match="^You still have to kill \* (?<mob>[^\(]+) \((?<where>.+?)(?<isdead> - Dead)?\)\.?$"
		script="xcp_index_line"
		name="trg_xcp_line"
		enabled="n"
		regexp="y"
		omit_from_output="y"
		sequence="500"
		>
	</trigger>

	<trigger
		match="^(?!You still have to kill \*)"
		script="xcp_index_line_end"
		name="trg_xcp_line_end"
		enabled="n"
		regexp="y"
		omit_from_output="n"
		sequence="500"
		>
	</trigger>

	<trigger
		match="You are not currently on a campaign."
		script="xcp_not_on_cp"
		name="trg_xcp_line_end_none"
		enabled="y"
		regexp="n"
		omit_from_output="n"
		sequence="500"
		>
	</trigger>
	
	<!-- area grabber -->
	<trigger
		match="              [ Listing all areas in range * to * ]"
		script="area_index_start_gag"
		name="trg_area_index_start_gag"
		enabled="y"
		regexp="n"
		omit_from_output="n"
		sequence="100"
		>
	</trigger>

	<trigger
		match="^From To   Lock  Builder          Area Name"
		script="area_index_start"
		name="trg_area_index_start"
		enabled="n"
		regexp="y"
		omit_from_output="n"
		sequence="100"
		>
	</trigger>
	
	<trigger
		match="---- ---- ----  ---------------  ------------------------------"
		name="trg_area_index_gag1"
		enabled="n"
		regexp="n"
		omit_from_output="n"
		sequence="100"
		>
	</trigger>
	
	<trigger
		match="---------------------------------------------------------------"
		name="trg_area_index_gag2"
		enabled="n"
		regexp="n"
		omit_from_output="n"
		sequence="100"
		>
	</trigger>
	
	<trigger
		match="^ (?<min>[0-9 ]{3})  (?<max>[0-9 ]{3})  (?<lock>[0-9 ]{3})  (?<author>.{15})  (?<area>.+)$"
		script="area_index_line"
		name="trg_area_index_line"
		enabled="n"
		regexp="y"
		omit_from_output="n"
		sequence="100"
		>
	</trigger>

	<trigger
		match="'Lock' means you cannot enter until you are that level or higher."
		script="area_index_end"
		name="trg_area_index_end"
		enabled="n"
		regexp="n"
		omit_from_output="n"
		sequence="100"
		>
	</trigger>
</triggers>

<variables>
	<variable name="example"></variable>
</variables>

<!--  Get our standard constants -->
<include name="constants.lua"/>

<!--  Script  -->
<script>
<![CDATA[
--[[
	Search and Destroy was originally written and released by WinkleWinkle (call it version 1.0.0)
	After Winkle left Aardwolf, Nokfah took over management and fixed some things. (call it version 1.1.0)
	Later on, Lunk took over management but got himself banned for unrelated reasons (call it version 1.2.0)
	
	Starling is the current developer as of 1 Jun 2017.  This version is numbered starting at 1.3.0

	Happy hunting, ninjas.
]]--

	require "serialize"
	require "gmcphelper"
	require "tprint"

	-- Variables --
	local showDebug = 0

	local search_destroy_id = "e50b1d08a0cfc0ee9c442001"
	local mob_mapper_id = "b555825a4a5700c35fa80800"

	local searchResult = {}
	local searchIndex = 0
	local cpList = {}
	local cpIndex = 1
	local mode = nil
	local gotoList = {}
	local gotoIndex = 1
	local currentRoom = {}
	local char_status
	local next_room = -1
	local last_area = ""
	local lastRoomId = -10
	local mapper_area_index = 0
	local last_substitute
	local speed = "run"
	local start_room_type
	local xrunto_area_id
	local showPK = GetVariable("showPK") or "true"
	local USER_check_vidblain = GetVariable("XRunToCheckVidblain") or "false"
	local USER_show_help = "true"
	--local USER_run_if_one_room = true
	local init_called = 0

	local area_range = {}

	local areaStartRooms = {}
	if (GetVariable("areaStartRooms") ~= nil) then			
		luastmt = "obj = " .. GetVariable("areaStartRooms")
		assert (loadstring (luastmt or "")) ()		
		areaStartRooms = obj
	end	
	
	-- List of default area start rooms.  Fixes xrunto/xrt to random-ish rooms if no "xset marked" starting room
	local areaDefaultStartRooms = {
		["aardington"] = { roomid = "47509", areaname = "Aardington Estate" },	-- A --
		["academy"] = { roomid = "35233", areaname = "Academy" },
		["adaldar"] = { roomid = "34400", areaname = "Battlefields of Adaldar" },
		["afterglow"] = { roomid = "38134", areaname = "Afterglow" },
		["agroth"] = { roomid = "11027", areaname = "Marshlands of Agroth" },
		["ahner"] = { roomid = "30129", areaname = "Kingdom of Ahner" },
		["alehouse"] = { roomid = "885", areaname = "Wayward Alehouse" },
		["amazon"] = { roomid = "1409", areaname = "Amazon Nation" },
		["amusement"] = { roomid = "29282", areaname = "Amusement Park" },
		["andarin"] = { roomid = "2399", areaname = "Blighted Tundra of Andarin" },
		["annwn"] = { roomid = "28963", areaname = "Annwn" },
		["anthrox"] = { roomid = "3993", areaname = "Anthrox" },
		["arena"] = { roomid = "25768", areaname = "Gladiator's Arena" },
		["arisian"] = { roomid = "28144", areaname = "Arisian Realm" },
		["ascent"] = { roomid = "43161", areaname = "First Ascent" },
		["astral"] = { roomid = "27882", areaname = "Astral Travels" },
		["atlantis"] = { roomid = "10573", areaname = "Atlantis" },
		["autumn"] = { roomid = "13839", areaname = "Eternal Autumn" },
		["avian"] = { roomid = "4334", areaname = "Avian Kingdom" },
		["aylor"] = { roomid = "32418", areaname = "Grand City Aylor" },
		["badtrip"] = { roomid = "32877", areaname = "Bad Trip" },		-- B --
		["bazaar"] = { roomid = "34454", areaname = "Onyx Bazaar" },
		["beer"] = { roomid = "20062", areaname = "Land of Beer Goblins" },
		["believer"] = { roomid = "25940", areaname = "Path of the Believer" },
		["blackrose"] = { roomid = "1817", areaname = "Black Rose" },
		["bliss"] = { roomid = "29988", areaname = "Wedded Bliss" },
		["caldera"] = { roomid = "26341", areaname = "Icy Caldera Mauldoon" },	-- C --
		["callhero"] = { roomid = "33031", areaname = "Call of Heroes" },
		["camps"] = { roomid = "4714", areaname = "Tournament Camps" },
		["canyon"] = { roomid = "25551", areaname = "Canyon Memorial Hospital" },
		["caravan"] = { roomid = "16071", areaname = "Gypsy Caravan" },
		["cards"] = { roomid = "6255", areaname = "House of Cards" },
		["carnivale"] = { roomid = "28635", areaname = "Olde Worlde Carnivale" },
		["cataclysm"] = { roomid = "19976", areaname = "Cataclysm" },
		["cats"] = { roomid = "40900", areaname = "Sheila's Cat Sanctuary" },
		["chasm"] = { roomid = "29446", areaname = "Chasm and Catacombs" },
		["chessboard"] = { roomid = "25513", areaname = "Chessboard" },
		["childsplay"] = { roomid = "678", areaname = "Child's Play" },
		["cineko"] = { roomid = "1507", areaname = "Aerial City of Cineko" },
		["citadel"] = { roomid = "14963", areaname = "Flying Citadel" },
		["conflict"] = { roomid = "27711", areaname = "Thandeld's Conflict" },
		["coral"] = { roomid = "4565", areaname = "Coral Kingdom" },
		["cougarian"] = { roomid = "14311", areaname = "Cougarian Queendom" },
		["cove"] = { roomid = "49941", areaname = "Kiksaadi Cove" },
		["cradle"] = { roomid = "11267", areaname = "Cradlebrook" },
		["crynn"] = { roomid = "43800", areaname = "Crynn's Church" },
		["damned"] = { roomid = "10469", areaname = "Halls of the Damned" },		-- D --
		["darklight"] = { roomid = "19642", areaname = "Darklight" },
		["darkside"] = { roomid = "15060", areaname = "Darkside Fractured Lands" },
		["ddoom"] = { roomid = "4193", areaname = "Desert Doom" },
		["deadlights"] = { roomid = "16856", areaname = "Deadlights" },
		["deathtrap"] = { roomid = "1767", areaname = "Deathtrap Dungeon" },
		["deneria"] = { roomid = "35006", areaname = "Realm of Deneria" },
		["desert"] = { roomid = "20186", areaname = "Desert Prison" },
		["desolation"] = { roomid = "19532", areaname = "Mountains of Desolation MoD" },
		["dhalgora"] = { roomid = "16755", areaname = "Dhal'Gora Outlands" },
		["diatz"] = { roomid = "1254", areaname = "Three Pillars Diatz" },	
		["diner"] = { roomid = "36700", areaname = "Tumari's Diner" },
		["dortmund"] = { roomid = "16577", areaname = "Dortmund" },
		["drageran"] = { roomid = "25894", areaname = "Drageran Empire" },
		["dread"] = { roomid = "26075", areaname = "Dread Tower" },
		["dsr"] = { roomid = "30030", areaname = "Diamond Soul Revelation" },
		["dundoom"] = { roomid = "25661", areaname = "Dungeon Doom" },
		["dunoir"] = { roomid = "14222", areaname = "Mount DuNoir" },
		["duskvalley"] = { roomid = "37301", areaname = "Dusk Valley" },
		["dynasty"] = { roomid = "30799", areaname = "Eighteenth 18th Dynasty" },
		["earthlords"] = { roomid = "42000", areaname = "Earth Lords" },		-- E --
		["earthplane"] = { roomid = "1354", areaname = "Earth Plane 4" },
		["elemental"] = { roomid = "41624", areaname = "Elemental Chaos" },
		["empire"] = { roomid = "32203", areaname = "Empire of Aiighialla" },
		["empyrean"] = { roomid = "14042", areaname = "Empyrean Streets of Downfall" },
		["entropy"] = { roomid = "29773", areaname = "Archipelago Entropy" },
		["fantasy"] = { roomid = "15205", areaname = "Fantasy Fields" },			-- F --
		["farm"] = { roomid = "10676", areaname = "Kimr's Farm" },
		["fayke"] = { roomid = "30418", areaname = "All in Fayke Day" },
		["fens"] = { roomid = "16528", areaname = "Curse Midnight Fens" },
		["fields"] = { roomid = "29232", areaname = "Killing Fields" },
		["firebird"] = { roomid = "32885", areaname = "Realm of the Firebird" },
		["firenation"] = { roomid = "41879", areaname = "Realm of the Sacred Flame" },
		["fireswamp"] = { roomid = "34755", areaname = "Fire Swamp" },
		["fortress"] = { roomid = "31835", areaname = "Goblin Fortress" },
		["fractured"] = { roomid = "17033", areaname = "Fractured Lands" },
		["ft1"] = { roomid = "1205", areaname = "Faerie Tales" },
		["ftii"] = { roomid = "26673", areaname = "Faerie Tales II FT2" },
		["gallows"] = { roomid = "4344", areaname = "Gallows Hill" },		-- G --
		["gathering"] = { roomid = "36451", areaname = "Gathering Horde" },
		["gauntlet"] = { roomid = "31652", areaname = "Gauntlet" },
		["gilda"] = { roomid = "4243", areaname = "Gilda and the Dragon" },
		["glamdursil"] = { roomid = "35055", areaname = "Glamdursil" },
		["glimmerdim"] = { roomid = "26252", areaname = "Brightsea Glimmerdim" },
		["gnomalin"] = { roomid = "34397", areaname = "Cloud City of Gnomalin" },
		["goldrush"] = { roomid = "15014", areaname = "Gold Rush" },
		["graveyard"] = { roomid = "28918", areaname = "Graveyard" },
		["greece"] = { roomid = "2089", areaname = "Ancient Greece" },
		["gwillim"] = { roomid = "25974", areaname = "Trouble with Gwillimberry" },
		["hatchling"] = { roomid = "34670", areaname = "Hatchling Aerie" },	-- H --
		["hawklord"] = { roomid = "40550", areaname = "Realm of the Hawklords" },
		["hedge"] = { roomid = "15146", areaname = "Hedgehog's" },
		["helegear"] = { roomid = "30699", areaname = "Helegear Sea" },
		["hell"] = { roomid = "30984", areaname = "Descent to Hell" },
		["hoard"] = { roomid = "1675", areaname = "Swordbreaker's Hoard" },
		["hodgepodge"] = { roomid = "30469", areaname = "Magical Hodgepodge" },
		["horath"] = { roomid = "91", areaname = "Broken Halls of Horath" },
		["horizon"] = { roomid = "31959", areaname = "Nebulous Horizon" },
		["illoria"] = { roomid = "10420", areaname = "Illoria" },		-- I --
		["imagi"] = { roomid = "36800", areaname = "Imagi's Nation" },
		["imperial"] = { roomid = "16966", areaname = "Imperial Nation" },
		["infamy"] = { roomid = "26641", areaname = "Realm of Infamy" },
		["infest"] = { roomid = "16165", areaname = "Infestation" },
		["insan"] = { roomid = "6850", areaname = "Insanitaria" },
		["jenny"] = { roomid = "29637", areaname = "Jenny's Tavern" },		-- J --
		["jotun"] = { roomid = "31508", areaname = "Jotunheim" },
		["kearvek"] = { roomid = "29722", areaname = "Keep of Kearvek" },		-- K --
		["kerofk"] = { roomid = "16405", areaname = "Kerofk" },
		["ketu"] = { roomid = "35114", areaname = "Ketu Uplands" },
		["kingsholm"] = { roomid = "27522", areaname = "Kingsholm" },
		["knossos"] = { roomid = "28193", areaname = "Great City of Knossos" },
		["kobaloi"] = { roomid = "10691", areaname = "Keep of the Kobaloi" },
		["kultiras"] = { roomid = "31161", areaname = "Kul Tiras" },
		["lab"] = { roomid = "28684", areaname = "Chaprenula's Laboratory" },			-- L --
		["labyrinth"] = { roomid = "31405", areaname = "Labyrinth" },
		["lagoon"] = { roomid = "30549", areaname = "Black Lagoon" },
		["landofoz"] = { roomid = "510", areaname = "Land of Oz" },
		["laym"] = { roomid = "6005", areaname = "Tai'rha Laym" },
		["legend"] = { roomid = "16224", areaname = "Land of Legend LoL" },
		["lemdagor"] = { roomid = "1966", areaname = "Storm Ships of Lem-Dagor" },
		["lidnesh"] = { roomid = "27995", areaname = "Forest of Li'Dnesh" },
		["livingmine"] = { roomid = "37008", areaname = "Living Mines of Dak'Tai" },
		["longnight"] = { roomid = "26367", areaname = "Into the Long Night" },
		["losttime"] = { roomid = "28584", areaname = "Island of Lost Time" },
		["lplanes"] = { roomid = "29364", areaname = "Lower Planes" },
		["maelstrom"] = { roomid = "38058", areaname = "Maelstrom" },	-- M --
		["manor"] = { roomid = "10621", areaname = "Death's Manor" },
		["masq"] = { roomid = "29840", areaname = "Masquerade Island" },
		["mayhem"] = { roomid = "1866", areaname = "Artificer's Mayhem" },
		["melody"] = { roomid = "14172", areaname = "Art of Melody" },
		["minos"] = { roomid = "20472", areaname = "Shadows of Minos" },
		["mistridge"] = { roomid = "4491", areaname = "Covenant of Mistridge" },
		["monastery"] = { roomid = "15756", areaname = "Monastery" },
		["mudwog"] = { roomid = "2347", areaname = "Mudwog's Swamp" },
		["nanjiki"] = { roomid = "11203", areaname = "Nanjiki Ruins" },		-- N --
		["necro"] = { roomid = "29922", areaname = "Necromancer's Guild" },
		["nenukon"] = { roomid = "31784", areaname = "Nenukon and the Far Country" },
		["newthalos"] = { roomid = "23853", areaname = "New Thalos" },
		["northstar"] = { roomid = "11127", areaname = "Northstar" },
		["nottingham"] = { roomid = "11077", areaname = "Nottingham" },
		["nulan"] = { roomid = "37900", areaname = "Plains of Nulan'Boar" },
		["nursing"] = { roomid = "31977", areaname = "Ascension Bluff Nursing Home" },
		["nynewoods"] = { roomid = "23562", areaname = "Nyne Woods" },
		["oceanpark"] = { roomid = "39600", areaname = "Ocean Adventure Park" },	-- O --
		["omentor"] = { roomid = "15579", areaname = "Witches of Omen Tor" },
		["origins"] = { roomid = "35900", areaname = "Tribal Origins" },
		["orlando"] = { roomid = "30331", areaname = "Hotel Orlando" },
		["paradise"] = { roomid = "29624", areaname = "Paradise Lost" },		-- P --
		["peninsula"] = { roomid = "35701", areaname = "Tairayden Peninsula" },
		["petstore"] = { roomid = "995", areaname = "Giant's Pet Store" },
		["pompeii"] = { roomid = "57", areaname = "Pompeii" },
		["promises"] = { roomid = "25819", areaname = "Foolish Promises" },
		["prosper"] = { roomid = "28268", areaname = "Prosper's Island" },
		["qong"] = { roomid = "16115", areaname = "Qong" },			-- Q --
		["quarry"] = { roomid = "23510", areaname = "Gnoll's Quarry" },
		["radiance"] = { roomid = "19805", areaname = "Radiance Woods" },
		["raga"] = { roomid = "19861", areaname = "Raganatittu" },	-- R --
		["raukora"] = { roomid = "6040", areaname = "Blood Opal of Rauko'ra" },
		["rebellion"] = { roomid = "10305", areaname = "Rebellion Nix" },
		["remcon"] = { roomid = "25837", areaname = "Reman Conspiracy" },
		["reme"] = { roomid = "32703", areaname = "City of Reme" },
		["rosewood"] = { roomid = "6901", areaname = "Rosewood Castle" },
		["ruins"] = { roomid = "16805", areaname = "Ruins of Diamond Reach" },
		["sagewood"] = { roomid = "28754", areaname = "Sagewood Grove" },		-- S --
		["sahuagin"] = { roomid = "34592", areaname = "Abyssal Caverns of Sahuagin" },
		["salt"] = { roomid = "4538", areaname = "Great Salt Flats" },
		["sanctity"] = { roomid = "10518", areaname = "Sanctity of Eternal Damnation" },
		["sanctum"] = { roomid = "15307", areaname = "Blood Sanctum" },
		["sandcastle"] = { roomid = "37701", areaname = "Sho'aram Shoaram Castle in the Sand" },
		["sanguine"] = { roomid = "15436", areaname = "Sanguine Tavern" },
		["scarred"] = { roomid = "34036", areaname = "Scarred Lands" },
		["sendhian"] = { roomid = "20288", areaname = "Adventures in Sendhia" },
		["sennarre"] = { roomid = "15491", areaname = "Sen'narre Lake" },
		["shouggoth"] = { roomid = "34087", areaname = "Temple of Shouggoth" },
		["siege"] = { roomid = "43265", areaname = "Kobold Seige Camp KSC" },
		["sirens"] = { roomid = "16298", areaname = "Siren's Oasis Resort" },
		["slaughter"] = { roomid = "1601", areaname = "Slaughterhouse" },
		["snuckles"] = { roomid = "182", areaname = "Snuckles Village" },
		["soh"] = { roomid = "25611", areaname = "School of Horror SOH1" },
		["solan"] = { roomid = "23713", areaname = "Town of Solan" },
		["songpalace"] = { roomid = "47013", areaname = "Palace of Song" },
		["spyreknow"] = { roomid = "34800", areaname = "Guardian's Spyre of Knowledge" },
		["stone"] = { roomid = "11386", areaname = "Fabled City of Stone" },
		["storm"] = { roomid = "6304", areaname = "Storm Mountain" },
		["stormhaven"] = { roomid = "20649", areaname = "Ruins of Stormhaven" },
		["stronghold"] = { roomid = "20572", areaname = "Dark Elf Stronghold DES" },
		["stuff"] = { roomid = "40400", areaname = "Stuff of Shadows" },
		["takeda"] = { roomid = "15952", areaname = "Takeda's Warcamp" },		-- T --
		["talsa"] = { roomid = "26917", areaname = "Empire of Talsa" },
		["temple"] = { roomid = "31597", areaname = "Temple of Shal'indrael" },
		["tanra"] = { roomid = "46913", areaname = "Tanra'vea" },
		["terra"] = { roomid = "19679", areaname = "Cracks of Terra" },
		["terramire"] = { roomid = "4493", areaname = "Fort Terramire" },
		["thieves"] = { roomid = "7", areaname = "Den of Thieves" },
		["times"] = { roomid = "28463", areaname = "Intrigues of Times Past" },
		["tirna"] = { roomid = "20136", areaname = "Tir na Nog" },
		["tol"] = { roomid = "16325", areaname = "Tree of Life" },
		["tombs"] = { roomid = "15385", areaname = "Relinquished Tombs" },
		["umari"] = { roomid = "36601", areaname = "Umari's Castle" },		-- U --
		["underdark"] = { roomid = "27341", areaname = "Underdark" },
		["uplanes"] = { roomid = "29364", areaname = "Upper Planes" },
		["uprising"] = { roomid = "15382", areaname = "Uprising" },
		["vale"] = { roomid = "1036", areaname = "Sundered Vale" },			-- V --
		["verdure"] = { roomid = "24090", areaname = "Verdure Estate" },
		["verume"] = { roomid = "30607", areaname = "Jungles of Verume" },
		["village"] = { roomid = "30850", areaname = "Peaceful Giant Village" },
		["vlad"] = { roomid = "15970", areaname = "Castle Vlad Shamir" },
		["volcano"] = { roomid = "6091", areaname = "Silver Volcano" },
		["werewood"] = { roomid = "30956", areaname = "Were Wood" },		-- W --
		["winter"] = { roomid = "1306", areaname = "Winterlands" },
		["wizards"] = { roomid = "31316", areaname = "War of the Wizards WoW" },
		["wildwood"] = { roomid = "322", areaname = "Wildwood" },
		["wonders"] = { roomid = "32981", areaname = "Seven Wonders" },
		["wooble"] = { roomid = "11335", areaname = "Wobbly Woes of Woobleville" },
		["woodelves"] = { roomid = "32199", areaname = "Wood Elves of Nalondir" },
		["wtc"] = { roomid = "37895", areaname = "Warrior Training Camp WTC" },
		["wyrm"] = { roomid = "28847", areaname = "Council of the Wyrm" },
		["xmas"] = { roomid = "6212", areaname = "Christmas Vacation" },			-- X --
		["xylmos"] = { roomid = "472", areaname = "Xyl's Mosaic" },
		["yarr"] = { roomid = "30281", areaname = "Misty Shores of Yarr" },			-- Y --
		["ygg"] = { roomid = "24186", areaname = "Yggdrasil: The World Tree" },
		["yurgach"] = { roomid = "29450", areaname = "Yurgach Domain" },
		["zangar"] = { roomid = "6164", areaname = "Zangar's Demonic Grotto" },		-- Z --
		["zodiac"] = { roomid = "15857", areaname = "Realm of the Zodiac" },
		["zoo"] = { roomid = "5920", areaname = "Aardwolf Zoological Park" },
		["zyian"] = { roomid = "729", areaname = "Dark Temple of Zyian" },
	}
	
	
	---------------------

	function init_plugin()
		if (init_called < 2) then
		
			Execute("sendgmcp request char")

			local localchar = char_status
			if (localchar ~= nil and tonumber(localchar.state) == 3) then
			
				if (init_called == 0) then
					Execute("xset suspend page size")
					init_called = 1
				else
				
					EnableTimer("tim_init_plugin", false)
					init_called = 2

					Execute("sendgmcp request room")
					
					-- trigger a search for area limits
					SendNoEcho("area 0 298")


				end
				
			end		
		end
	end

	function OnPluginBroadcast (msg, id, name, text)

		-- Look for GMCP handler.
		if (id == '3e7dedbe37e44942dd46d264') then
			if (text == "room.info") then
				res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info")

				luastmt = "gmcpdata = " .. gmcparg
				assert (loadstring (luastmt or "")) ()

				currentRoom.roomid = gmcpval("num")

				-- Stall timer every time we move
				if (IsTimer("done_moving") == error_code.eOK) then
					ResetTimer("done_moving")
				end
				
				-- gmcp request of area also gets room.info so only request area if it has changed AND we are done moving
				-- otherwise we would continuously get room gmcp and piss off Lasher				
				if (currentRoom.areaid ~= gmcpval("zone")) then				
					currentRoom.areaid = gmcpval("zone")	
					
					-- We have changed areas, create the timer if it doesn't exist
					if (IsTimer("done_moving") ~= error_code.eOK) then					
						AddTimer("done_moving", 0, 0, .5, "", timer_flag.Enabled + timer_flag.OneShot, "done_moving")
					end																														
				end				
			elseif (text == "room.area") then
				res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.area")
				luastmt = "gmcpdata = " .. gmcparg
				assert (loadstring (luastmt or "")) ()
			
				currentRoom.areaname = gmcpval("name")
			elseif (text == "char.status") then
				res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.status")
				luastmt = "gmcpdatacharstatus = " .. gmcparg
				assert (loadstring (luastmt or "")) ()
				char_status = gmcpdatacharstatus
				--tprint(char_status)

				--currentState = tonumber(gmcpval("status.state"))
			end
		end
	end
	
	function done_moving()
		Send_GMCP_Packet("request area")
	end
	
	function set_speed(name, line, wildcards)
		if (wildcards.speed ~= "") then
			speed = wildcards.speed
		else
			if (speed == "walk") then
				speed = "run"
			else
				speed = "walk"
			end
		end
		ColourNote("darkorange", "", "Move speed:" .. speed)
	end

	function move_trigger(name, line, wildcards)
		
		if (wildcards.roomid ~= "") then
			move(wildcards.roomid, wildcards.speed)
		end	
	end

	function move(roomid, temp_speed)
	
		if (temp_speed == nil or temp_speed == "") then
			temp_speed = speed
		end
		
		if (temp_speed == "walk") then
			Note("walking to " .. roomid)
			Execute("mapper walkto " .. roomid)
		else
			Execute("mapper goto " .. roomid)
		end
	end
	
	local last_cp_check = os.time()
	local xcp_flag = false
	function xcp_check(name, line, wildcards)

		DebugNote("xcp_check")
		
		xcp_flag = true

		-- prevent double cp checks from different plugins
		local time_check = os.time()
		if ((time_check - last_cp_check) < 2) then
			return
		end
		last_cp_check = time_check

		cpList = {}
		cpIndex = 1
		EnableTrigger("trg_xcp_line", true)
		EnableTrigger("trg_xcp_line_end", false)
		
		if (wildcards.param == "test") then
			cp_simulate()
		else
			Send("cp c")


		end
	end


	function xcp_index_line(name, line, wildcards)

		EnableTrigger("trg_xcp_line_end", true)

		if (cpList == nil) then
			cpList = {}
			cpIndex = 1
		end
		
		DebugNote("xcp_index_line:" .. wildcards.mob)
		cpIndex = get_rooms_areas(cpList, cpIndex, wildcards.where, wildcards.mob, 1, wildcards.isdead)	
		
	end


	local get_rooms_areas_sql = 
		" SELECT r.uid as room, r.name as roomName, a.uid as area, a.name as areaName, 'room' as type, info " ..
		" FROM rooms r " ..
		" INNER JOIN areas a ON r.area = a.uid " ..
		" WHERE r.name = %s " ..
		" UNION " ..
		" SELECT -1 as room, '' as roomName, uid as area, name as areaName, 'area' as type, '' as info " ..
		" FROM areas " ..
		" WHERE name = %s " ..
		" ORDER BY type ASC "

	function get_rooms_areas(list, listIndex, place, mobName, qty, isDead)
		local localLevel = -1
		if (char_status == nill) then
			DebugNote("Unknown char status")
			return
		else
			localLevel = tonumber(char_status.level)
		end
		
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))

		-- find room/area
		local select = string.format (get_rooms_areas_sql, fixsql(place), fixsql(place))
		DebugNote(select)
		
		local index = 0
		local lastMobSignature = ""
		for row in db:nrows(select) do

			if (row.type == "room") then				
			
				local tolerance = 11
				local min = (area_range[row.areaName] or {min = 0}).min 
				local max = (area_range[row.areaName] or {max = 300}).max
				-- debug
				--min = 0
				--max = 300

				-- filter out spammy neighbouring rooms.. too much spam!
				local mobSignature = row.areaName .. "|" .. mobName
				local showItem = false
				DebugNote("lastMobSignature:" .. lastMobSignature .. ":mobSignature:" .. mobSignature)
				
				-- sanitize text room ids for "unmappable" rooms that are now being mapped
				row.room = (tonumber(row.room) or "nomap")

				if (lastMobSignature ~= mobSignature) then
					if (localLevel >= (min - tolerance) and localLevel <= (max + tolerance)) then
						
						index = index + 1
				
						list[listIndex] = {
							qty = tonumber(qty),
							mob = mobName,
							type = row.type,
							roomId = row.room,
							roomName = row.roomName,
							areaId = row.area,
							areaName = row.areaName,
							area = row.area,
							isDead = isDead,
							min = min,
							max = max,
							info = row.info}

							listIndex = listIndex + 1
					else
						local link = string.format("Ignoring due to level : %s in '%s' (%s) [%s-%s]", mobName, row.roomName, row.area, min, max)
						Hyperlink("xm move " .. row.room, link, "Move to room " .. row.room, "Khaki", "black", 0)
						print("")
					end
				end
				
				lastRoomId = row.room
				lastMobSignature = mobSignature
				
			else -- area

				index = index + 1
			
				DebugNote("get_rooms_areas - area:" .. index .. ":" .. mobName)
			
				list[listIndex] = {
					qty = tonumber(qty),
					mob = mobName,
					type = row.type,
					roomId = row.room,
					roomName = row.roomName,
					areaId = row.area,
					areaName = row.areaName,
					area = row.area,
					isDead = isDead}

				listIndex = listIndex + 1
			
			end
		end
		db:close_vm()
		
		DebugNote(mobName .. " index:" .. index)
		-- add unknown mobs
		if (index == 0) then
			
			list[listIndex] = {
				qty = tonumber(qty),
				mob = mobName,
				type = "unknown",
				roomId = 0,
				roomName = place,
				areaId = "UNKNOWN",
				areaName = "UNKNOWN",
				area = "UNKNOWN",
				isDead = isDead}

			listIndex = listIndex + 1	
		end
		
		return listIndex
	end
	
	function print_rooms_areas(list, command)
		DebugNote("print_rooms_areas:" .. command .. ":" .. #list)
	
		--reset signature for next search
		lastMobSignature = ""

		if (USER_show_help == "true") then
			ColourNote("Gray", "", "Type '" .. command .. " <Index>' or click link, to go to that item")
			ColourNote("Gray", "", "  Index     Target          - Location")
			ColourNote("Gray", "", "---------------------------------------")
		end
		
		local index = 0
		for key, value in ipairs(list) do
		
			index = index + 1
		
			local qty = ""
			if (value.qty > 1) then
				qty = string.format("%s * ", value.qty)
			end

			local mobText = qty .. value.mob
			local deadFlag = false
			if (value.isDead ~= nil and value.isDead ~= "") then
				mobText = mobText .. " [Dead]"
				deadFlag = true
			end
			
			DebugNote("xcp_index_line_end:" .. value.mob)
			local link
			local color
			if (value.type == "area") then
				link = string.format("~~~  %s %s - %s", padRight(key, 6, " "), padRight(mobText, 20, " "), padRight(value.areaId, 12, " "))
				if (deadFlag == false) then
					color = "Snow"
				else
					color = "DimGray"
				end
			elseif (value.type == "room") then
				
				link = string.format("~~~  %s %s - '%s' (%s) - %s [%s-%s]", 
					padRight(key, 6, " "), 
					padRight(mobText, 20, " "), 
					value.roomName, 
					padRight(value.roomId, 5, " "), 
					value.areaId, value.min, value.max)
				if (deadFlag == false) then
					color = "lightblue"
				else
					color = "DimGray"
				end
			else -- unknown
				link = string.format("~~~  %s %s - '%s' is Unknown", padRight(key, 6, " "), padRight(mobText, 20, " "), value.roomName)
				if (deadFlag == false) then
					color = "Crimson"
				else
					color = "DarkRed"
				end
			end		
			
			Hyperlink(command .. " " .. key, link, "Start CP item " .. key, color, "black", 0)
			
			if (value.type == "area") then
				Hyperlink("roomnote area " .. value.areaId , "   [notes]", "Show notes for " .. key, "lightgreen", "black", 0)
			end
			print("")
		end
		
		if (index == 0) then
			ColourNote("darkorange", "", "   No campaign items to show.")
		end

		if (USER_show_help == "true") then
			ColourNote("Gray", "", "---------------------------------------")
		end
	end

	function xcp_index_line_end(name, line, wildcards)
		DebugNote("xcp_index_line_end")

		EnableTrigger("trg_xcp_line", false)
		EnableTrigger("trg_xcp_line_end", false)

		if (xcp_flag == false) then
			return
		end
		xcp_flag = false
		
		print_rooms_areas(cpList, "xcp")
		
		-- broadcast this data for other plugins to consume
		local ser = serialize.save_simple(cpList)
		--print(ser)
		BroadcastPlugin(669, ser)
	end

	function xcp_not_on_cp(name, line, wildcards)
		DebugNote("xcp_not_on_cp")
		EnableTrigger("trg_xcp_line", false)
		EnableTrigger("trg_xcp_line_end", false)

		if (xcp_flag == false) then
			return
		end
		xcp_flag = false
		
		-- broadcast this data for other plugins to consume
		local ser = serialize.save_simple(cpList)
		--print(ser)
		BroadcastPlugin(669, ser)
	end
	

	function goto_number(name, line, wildcards)
		Note("goto_number: " .. wildcards.id)

		if (wildcards.id == nil or wildcards.id == "") then
			gotoIndex = 1
		else
			gotoIndex = tonumber(wildcards.id)
		end

		if (gotoList[gotoIndex] ~= nil) then
			if (tonumber(gotoList[gotoIndex]) == nil) then
				-- go to an area
				Execute("xrt " .. gotoList[gotoIndex])
			else
				next_room = gotoList[gotoIndex]
				goto_roomid(gotoList[gotoIndex])
			end
		else
			ColourNote("darkorange", "", "No destination exists")
		end
	end

	function goto_roomid(roomid)

		local dest_in_vidblain = is_vidblain_area(roomid)
		local both_in_vidblain = dest_in_vidblain and is_vidblain_area(currentRoom.roomid)


		if (dest_in_vidblain == true and both_in_vidblain == false) then
			Execute("xmapper move 11910")
			Execute("enter hole")

			local func = function() Execute("xmapper move " .. roomid) end
			execute_in_area("vidblain_hack", "vidblain", func)

		else
			Execute("xmapper move " .. roomid)
		end
	end

	local is_vidblain_area_sql =  
		"SELECT area " ..
		"FROM rooms " ..
		"WHERE uid = %s "

	function is_vidblain_area(roomid)
		if (USER_check_vidblain == "false") then
			return false
		end

		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))

		local select = string.format (is_vidblain_area_sql, fixsql(roomid))
		for row in db:nrows(select) do
			--Note(row.area)
			local areaid = row.area
			if (areaid == "vidblain" or
				areaid == "darklight" or
				areaid == "imperial" or
				areaid == "omentor" or
				areaid == "sendhian") then
				db:close_vm()
				return true
			end
		end		
		db:close_vm()
		return false
	end

	function goto_next(name, line, wildcards)

		DebugNote("next:" .. next_room .. ":" .. currentRoom.roomid)
		if (tonumber(next_room) == tonumber(currentRoom.roomid)) then
			gotoIndex = gotoIndex + 1
		end

		if (gotoList[gotoIndex] ~= nil) then
			ColourNote("darkorange", "", "Goto - " .. gotoIndex .. " of " .. #gotoList)
			next_room = gotoList[gotoIndex]
			Execute("xmapper move " .. next_room)
		else
			ColourNote("darkorange", "", "No destination exists")
		end
	end

	function goto_cp(name, line, wildcards)
		cpIndex = tonumber(wildcards.index) or 1
		print("cp index: " .. cpIndex)
		mode = "cp"
		DebugNote("goto_cp:" .. wildcards.index)
		BroadcastPlugin(670, "cp")
		goto_list_item(cpList, cpIndex)
	end
	
	function goto_list_item(list, index)
		
		-- reset room list
		gotoList = {}
		gotoIndex = 1

		local localItem = list[index]
		local localRoom = currentRoom
		
		if (localItem ~= nil and localRoom ~= nil and localRoom.areaid ~= nil) then
		
			-- send this mob name to S&D plugin
			DebugTPrint("goto_list_item - localItem", localItem)
		
			if (localItem.type == "area") then
				DebugNote("area type")
				remote_guess_mob_name(localItem.mob, localItem.areaId, true)
				if (localRoom.areaid ~= localItem.areaId) then
					Execute("xrt " .. localItem.areaId)
				end

				local func = function() Execute("x_ht " .. localItem.mob) end
				execute_in_area("goto_list_item_area", localItem.areaId, func)
			else -- "room"
				DebugNote("room type")
				remote_guess_mob_name(localItem.mob, localItem.areaId, true)
				search_rooms(localItem.roomName .. "|" .. localItem.areaId, "area", localItem.mob)
			end
		else
			ColourNote("darkorange", "", "No item exists, or data busy (try again)")
		end
	end

	local xrun_to_sql_uid =  
		"SELECT r.uid, r.name as room, r.area " ..
		"FROM rooms r " ..		
		"WHERE r.area like %s " ..
		"ORDER BY r.name "
		
	local xrun_to_sql_name =  
		"SELECT r.uid, r.name as room, r.area " ..
		"FROM rooms r " ..
		"INNER JOIN areas a ON a.uid = r.area " ..
		"WHERE r.area like %s OR a.name like %s " ..
		"ORDER BY r.name "
	
	function xrun_to(name, line, wildcards)
		-- finds your mapper database file and opens it.
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))

		-- HACK for ftii (allows one to 'xrt ft2' as well as 'xrt ftii')
		if (wildcards[1] == "ft2") then wildcards[1] = "ftii" end
		
		-- Check for xset marked room
		local startRoom = get_start_room(wildcards[1])
		if (startRoom ~= -1) then
			-- start room is either 'xset marked' or has a preset default, so we'll go there.
			ColourNote("darkorange", "", "X-runto area: " .. wildcards[1] .. ", room ID: " .. startRoom .. " (" .. start_room_type .. ")")
			goto_roomid(startRoom)
		else
			-- start room is not 'xset marked' and no preset default was found.
			-- so, search mapper DB for room with lowest id for the area and make
			-- a guess that it's the start room.  It usually guesses wrong.  Also,
			-- the room id isn't necessarily the lowest.  Player is often sent to
			-- a random-ish room, and if there are aggros it can get them killed.
		
			-- try exact area name first.
			local select = string.format (xrun_to_sql_uid, fixsql(wildcards[1]))
			DebugNote("xrun_to (1)- " .. select)
			
			for row in db:nrows(select) do
				ColourNote("darkorange", "", "X-runto area: " .. row.area .. ", room ID: " .. row.uid .. " (" .. start_room_type .. ")")
				goto_roomid(row.uid)
				db:close_vm()
				return
			end
			db:close_vm()
			
			-- try a wildcard match
			local like = fixsql("%" .. wildcards[1] .. "%")
			select = string.format (xrun_to_sql_name, like, like)
			DebugNote("xrun_to (2)- " .. select)

			for row in db:nrows(select) do
				ColourNote("darkorange", "", "X-runto area: " .. row.area .. ", room ID: " .. row.uid .. " (" .. start_room_type .. ")")
				goto_roomid(row.uid)
				db:close_vm()
				return
			end
			db:close_vm()

			-- if all of the above fails, just go via Aardwolf runto.
			ColourNote("darkorange", "", "X-runto: No matching rooms found.  Going via Aardwolf runto...")
			Execute("xmapper move 32418") -- recall
			Execute("runto " .. wildcards[1])	
		end			
	end

	function xset_pk(name, line, wildcards)

		if (showPK == "true") then
			showPK = "false"
		else
			showPK = "true"
		end
		
		SetVariable("showPK", showPK)
		ColourNote("DarkOrange", "", "Show PK room flag : " .. showPK)

	end

	function xset_to_mark(name, line, wildcards)
		areaStartRooms[currentRoom.areaid] = { areaname = currentRoom.areaname, roomid = currentRoom.roomid }
		ColourNote("darkorange", "", "\n" .. currentRoom.roomid .. " set as starting room for " .. currentRoom.areaid .. "\n")
		SetVariable("areaStartRooms", serialize.save_simple(areaStartRooms))
	end
	
	function get_start_room(area)
		--tprint(areaStartRooms)
		-- if area start has been set via 'xset mark' then that's where you'll go.  The function will exit as soon
		-- as it hits a 'return' statement, preventing the rest of the code from executing (which is good)
		local cleanedArea = string.lower(area)
		start_room_type = "xset mark"
		if (areaStartRooms[cleanedArea] ~= nil) then 			
			return areaStartRooms[cleanedArea].roomid	-- exact match on area id
		end
				
		for key, val in pairs (areaStartRooms) do			
			if (string.match(string.lower(key), cleanedArea) ~= nil) then 				
				return val.roomid	-- string match on key
			elseif (string.match(string.lower(val.areaname), cleanedArea) ~= nil) then								
				return val.roomid	-- string match on area name
			end
		end
		
		-- if area start room hasn't been set via 'xset mark', then get the pre-defined default start room from the
		-- table areaDefaultStartRooms.  Upper and Lower Planes have the same default room, which solves issues with
		-- xrunto going into a random pool.
		start_room_type = "default"
		if (areaDefaultStartRooms[cleanedArea] ~= nil) then 			
			return areaDefaultStartRooms[cleanedArea].roomid	-- exact match on area id
		end
		for key, val in pairs (areaDefaultStartRooms) do
			if (string.match(string.lower(key), cleanedArea) ~= nil) then 				
				return val.roomid	-- string match on key
			elseif (string.match(string.lower(val.areaname), cleanedArea) ~= nil) then								
				return val.roomid	-- string match on area name
			end
		end		
		
		-- If no "xset mark" and no entry in the defaults table, random-ish room will be looked up in mapper....
		start_room_type = "guess via mapper lookup"
		return -1		
	end

	---- room notes --------

	function room_note_area(name, line, wildcards)
		if (wildcards.areaid == "") then
			get_notes(currentRoom.areaid, nil)
		else
			get_notes(wildcards.areaid, nil)
		end
	end

	function room_note(name, line, wildcards)
		get_notes(nil, currentRoom.roomid)
	end

	function get_notes(areaid, roomid, text_only)

		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))

		local sql =  " SELECT b.uid, b.notes "
		sql = sql .. " FROM bookmarks b "
		if (areaid ~= nil) then
			sql = sql .. " INNER JOIN rooms r ON b.uid = r.uid "
			sql = sql .. " WHERE r.area = " .. fixsql(areaid)
		else
			sql = sql .. " WHERE b.uid = " .. fixsql(roomid)
		end
		sql = sql .. " ORDER BY b.uid "
		DebugNote(sql)

		local index = 0

		if (areaid ~= nil) then
			Simulate("\nNotes for " .. getAreaName(areaid) .. "\n")
		end

		for row in db:nrows(sql) do
			index = index + 1

			if (text_only == true) then
				local line = string.format("    note:'%s'", row.notes)
				Hyperlink("xmapper move " .. row.uid, line, "go to room " .. row.uid, "lightblue", "black", 0)		
			else
				local line = string.format("    (%s) %s", row.uid, row.notes)
				Hyperlink("xmapper move " .. row.uid, line, "go to room " .. row.uid, "lightblue", "black", 0)
				print("")
			end		
		end
		db:close_vm()
		
		if (areaid ~= nil and index == 0 and text_only ~= true) then
			Simulate("\tNo notes.\n")
		end
	end



	function getRoomByMob(mobName)
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))

		local sql =  "SELECT roomid, mobname, count "
		sql = sql .. "FROM mobs "
		sql = sql .. "WHERE mobname = %s "
		sql = sql .. "ORDER BY count desc "

		for row in db:nrows(string.format (sql, fixsql(uid))) do
			db:close_vm()
			return row.name
		end
		db:close_vm()
	end


	function getAreaName(uid)
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))

		local sql =  "SELECT name FROM areas WHERE uid = %s"
		for row in db:nrows(string.format (sql, fixsql(uid))) do
			db:close_vm()
			return row.name
		end
		db:close_vm()
		
		return uid
	end

	function getAreaUid(name)

		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))

		local sql =  "SELECT uid FROM areas WHERE name = %s order by uid "

		local areas = {}
		local index = 0
		DebugNote("getAreaUid:" .. fixsql(name))
		for row in db:nrows(string.format (sql, fixsql(name))) do
			DebugNote(row.uid .. ":" .. name)
			index = index + 1
			areas[index] = {uid = row.uid, name = name}
		end
		
		db:close_vm()
		return areas
	end


	function map_area(name, line, wildcards)
		search_rooms(wildcards.loc, 'area', wildcards.mob)
	end

	function map_area_all(name, line, wildcards)
		search_rooms(wildcards.loc .. "|all", 'all', wildcards.mob)
	end
	
	local search_rooms_sql = 
		"SELECT r.uid as uid, r.name as name, info, r.area as area, " ..
		"ifnull(a.name, r.area) as area_name, 1 as DisplayOrder " .. 
		"FROM rooms r " ..
		"LEFT OUTER JOIN areas a ON r.area = a.uid " ..
		"WHERE r.name = %s " ..
		"AND (%s = 'all' OR (a.name = %s OR r.area = %s)) " ..
		
		"UNION " ..
		
		"SELECT r.uid, r.name, info, r.area, " ..
		"ifnull(a.name, r.area) as area_name, 0 as DisplayOrder " .. 
		"FROM rooms r " ..
		"LEFT OUTER JOIN areas a ON r.area = a.uid " ..
		"WHERE r.name <> %s " ..
		"AND r.name LIKE %s " .. 
		"AND (%s = 'all' OR (a.name = %s OR r.area = %s)) " ..
		"ORDER BY Area, DisplayOrder DESC "
	
	function search_rooms(room, searchType, fullMobName)
		DebugNote("search_rooms(" .. room .."," .. searchType .. "," .. fullMobName .. ")")
	
		if (room == nil or room == "") then
			Note("map_area() error : room is not known")
			return
		end

		-- room|area
		local parts = split(room, "[^|]+") -- pipe delimited
		local room = parts[1]
		local area_id
		if (#parts == 2) then
			area_id = parts[2]
		else
			if (currentRoom ~= nil) then
				area_id = currentRoom.areaid
			else
				ColourNote("darkorange", "", "Area not known, falling back to mapper list")
				Execute("mapper list " .. parts[1])
			end
		end

		if (room == nil) then
			Note("map_area() - Room not known")
			return
		end

		like = "%"..room.."%"

		-- i forget what this does? Strip out a leading " ?
		--if string.sub(room,1,1) == "\"" and string.sub(room,-1) == "\"" then
		--	like = string.sub(room,2,-2)
		--end

		local select = string.format(search_rooms_sql, 
			fixsql(room), 
			fixsql(area_id), 
			fixsql(area_id), 
			fixsql(area_id), 
			fixsql(room), 
			fixsql(like), 
			fixsql(area_id), 
			fixsql(area_id), 
			fixsql(area_id))
		DebugNote(select)
			
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))
		
		local results = {}
		local roomid_list = {}
		
		for row in db:nrows(select) do

			-- sanitize text room ids for "unmappable" rooms that are now being mapped
			local id = (tonumber(row.uid) or -1)
			results[#results + 1] = { 
				uid = id, 
				name = row.name,
				info = row.info,
				area = row.area_name,
				areaid = row.area or row.area_name -- make safe against bad dbs			
			}
			
			-- make a list of room ids
			if (id > 0) then
				roomid_list[#roomid_list + 1] = id
			end

		end   -- finding rooms
		db:close_vm()
		
		local mob_mapping = {}
		
		local freq_total = mob_mapping[-1] or 0
		DebugNote("freq_total:" .. freq_total)
		
		-- add mob to room mapping
		for key, value in ipairs(results) do
		
			local freq = mob_mapping[value.uid]
			if (freq ~= nil) then
				value.freq = math.floor((freq / freq_total) * 100)
			else
				value.freq = 0
			end	
		end
		
		print_rooms(results)
	end
	
	function IPRINT_ROOMS(json)
		-- load serialize.save_simple data
		luastmt = "gPrintRooms = " .. json
		assert (loadstring (luastmt or "")) ()
		
		print_rooms(gPrintRooms)
	end
	
	-- uses results{ areaid, area, info, name, uid, freq }
	function print_rooms(results)
		-- print results
		gotoList = {}
		mapper_area_index = 0
		local last_area = ""

		DebugTPrint("results", results)

		if (USER_show_help == "true") then
			ColourNote("Gray", "", "Type 'go <Index>' or click link, to go to that room")
			ColourNote("Gray", "", "  Index   Room Name   (uid)")
			ColourNote("Gray", "", "----------------------------")
		end
		
		for key, value in ipairs(results) do
			DebugNote("area: " .. value.areaid )
			
			if (last_area ~= value.areaid) then
			
				if (mapper_area_index == 0) then
					local areaLine = string.format("~~~ %s %s", 
						mapper_area_index, 
						value.areaid)
					Hyperlink("go " .. mapper_area_index, areaLine, "go to area " .. value.areaid, "silver", "black", 0)
					gotoList[mapper_area_index] = value.areaid
					
					mapper_area_index = mapper_area_index + 1
				else
					local areaLine = string.format("~~~   %s", value.areaid)
					Hyperlink("xrt " .. value.areaid, areaLine, "go to area " .. value.areaid, "silver", "black", 0)
				end				
				print("")
				last_area = value.areaid				
			end
		
			local line1 = string.format("~~~ %s ", 
				padRight(mapper_area_index, 3, " "))
			Hyperlink("go " .. mapper_area_index, line1, "go to item " .. mapper_area_index, "lightblue", "black", 0)
			
			-- mob name? 
			if (value.mobname ~= nil) then
				local mobline = padRight(value.mobname .. " ", 20, " ")
				Hyperlink("go " .. mapper_area_index, mobline, "go to item " .. mapper_area_index, "snow", "black", 0)
			end

			
			local line2 = string.format("%s  (%s) ", 
				padRight(string.gsub(value.name, "@[a-zA-Z]", ""), 20, " "), 
				value.uid)
			Hyperlink("go " .. mapper_area_index, line2, "go to item " .. mapper_area_index, "lightblue", "black", 0)
			
			-- mob to room
			if (value.freq > 0) then
				ColourTell ("DarkOrange", "black", " (" .. value.freq .. "%) ")
			end
			
			Hyperlink("mapper where " .. value.uid, 
				"   {?}", 
				"click for speedwalk to this room", 
				"LightSteelBlue ", 
				"black", 
				0)
			gotoList[mapper_area_index] = value.uid
			
			print("")
			mapper_area_index = mapper_area_index + 1
		end
			

		if (mapper_area_index == 0) then
			ColourNote("darkorange", "", "No matching rooms found.")
		end
		
		if (USER_show_help == "true") then
			ColourNote("Gray", "", "-------------------------------------")
		end	

	end

	function map_purgeroom (name, line, wildcards)
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))

		Note(string.format ("delete from exits WHERE fromuid = %s;", fixsql(currentRoom.roomid)))
		dbcheck (db:execute (string.format ("delete from exits WHERE fromuid = %s;", fixsql(currentRoom.roomid))))
		Note(string.format ("delete from exits WHERE touid = %s;", fixsql(currentRoom.roomid)))
		dbcheck (db:execute (string.format ("delete from exits WHERE touid = %s;", fixsql(currentRoom.roomid))))
		Note(string.format ("delete from rooms_lookup WHERE uid = %s;", fixsql(currentRoom.roomid)))
		dbcheck (db:execute (string.format ("delete from rooms_lookup WHERE uid = %s;", fixsql(currentRoom.roomid))))
		Note(string.format ("delete from rooms WHERE uid = %s;", fixsql(currentRoom.roomid)))
		dbcheck (db:execute (string.format ("delete from rooms WHERE uid = %s;", fixsql(currentRoom.roomid))))
		db:close_vm()
		
		ColourNote("darkorange", "", "Purged room (" .. currentRoom.roomid .. ") from the mapper database.")
	end

	local cp_simulate_toggle = 0
	function cp_simulate(name, line, wildcards)	

		Simulate("\n")	

		if (cp_simulate_toggle == 0) then
			Simulate("You still have to kill * Isscheburqua (Insanitaria)\n")
			Simulate("You still have to kill * a rook citizen (Avian Kingdom)\n")
			Simulate("You still have to kill * Lea, the farmer's daughter (Farmyard)\n")
			Simulate("You still have to kill * a rook citizen (Nesting Home)\n")
			Simulate("You still have to kill * a demon school student (The School of Horror)\n")
			Simulate("You still have to kill * a hookle fish (Black Lagoon)\n")
			Simulate("You still have to kill * Harry (Unknown Tower - Dead)\n")
			Simulate("You still have to kill * a former court jester (The Labyrinth)\n")
			Simulate("You still have to kill * Parent (The Kitchen)\n")
			Simulate("You still have to kill * a wealth redistribution specialist (Empyrean, Streets of Downfall)\n")
			Simulate("You still have to kill * the reaching thorns (Eternal Autumn)\n")
			Simulate("You still have to kill * Redtooth (Mossflower Wood - Dead)\n")
			Simulate("You still have to kill * Castle Guard (Rebellion of the Nix)\n")
			Simulate("You still have to kill * Jules (The Amazon Nation)\n")
			Simulate("You still have to kill * an earth fiend (The Broken Halls of Horath)\n")
			Simulate("You still have to kill * the spirit of Bakarne (The Empire of Aiighialla)\n")
			Simulate("You still have to kill * Elfgar Sous-Fled (Some Place)\n")
			Simulate("You still have to kill * the heart of a sandstorm (Living Mines of Dak'Tai)\n")
			cp_simulate_toggle = 1
		else
			Simulate("You still have to kill * a former court jester (The Labyrinth)\n")
			Simulate("You still have to kill * the heart of a sandstorm (Buried in the Great Desert's unrelenting dunes)\n")
			Simulate("You still have to kill * Parent (The Kitchen)\n")
			Simulate("You still have to kill * a rhino seraph (A Corridor of Cinnamon and Silver)\n")
			Simulate("You still have to kill * A sprite prisoner (A cell)\n")
		
			cp_simulate_toggle = 0
		end
		Simulate("Note: Dead means that the target is dead, not that you have killed it.\n")
		Simulate("\n")
		Simulate("You have 6 days, 23 hours and 56 minutes left to finish this campaign.\n")
		Simulate("\n")	

	end

	-------- Area level capture -------


	--Commander Barcett tells you ' Good luck in your campaign!''

	function area_index_start_gag(name, line, wildcards)	
		DebugNote("area_index_start_gag - " .. wildcards[1] .. ":" .. wildcards[2])
		if (wildcards[1] == "0" and wildcards[2] == "298") then
			EnableTrigger("trg_area_index_start", true)
			EnableTrigger("trg_area_index_line", false)
			EnableTrigger("trg_area_index_end", false)
			EnableTrigger("trg_area_index_gag1", true)
			EnableTrigger("trg_area_index_gag2", true)
		else -- not an area index command
			EnableTrigger("trg_area_index_start", false)
			EnableTrigger("trg_area_index_line", false)
			EnableTrigger("trg_area_index_end", false)
			EnableTrigger("trg_area_index_gag1", false)
			EnableTrigger("trg_area_index_gag2", false)
		end
	end

	function area_index_start(name, line, wildcards)
		DebugNote("area_index_start")
		EnableTrigger("trg_area_index_start", false)
		EnableTrigger("trg_area_index_line", true)
		EnableTrigger("trg_area_index_end", true)
		
		area_range = {}
		
		ColourNote("DarkOrange", "", "*** Indexing area levels...")
	end

	function area_index_line(name, line, wildcards)
		DebugNote("area_index_line")

		area_range[Trim(wildcards.area)] = { 
			area = Trim(wildcards.area), 
			min = tonumber(Trim(wildcards.min)), 
			max = tonumber(Trim(wildcards.max)),
			lock = tonumber(Trim(wildcards.lock)) or 0 }		
		--tprint(area_range[wildcards.area])

	end

	function area_index_end(name, line, wildcards)
		DebugNote("area_index_end")

		EnableTrigger("trg_area_index_start", false)
		EnableTrigger("trg_area_index_line", false)
		EnableTrigger("trg_area_index_end", false)
		EnableTrigger("trg_area_index_gag1", false)
		EnableTrigger("trg_area_index_gag2", false)

		ColourNote("DarkOrange", "", "*** Area levels indexed!")
		
		DoAfterSpecial(2, "xset resume page size", sendto.execute)

	end

	------ Execute in Area ------

	local execute_in_area_array = {}

	function execute_in_area(id, areaId, functionPointer)

		execute_in_area_array[id] = { 
			areaId = areaId, 
			func = functionPointer, 
			index = 0, 
			active = true,
			lastState = 3, -- standing
			standIndex = 0 -- count of stands in a row
			}
		--tprint(execute_in_area_array)
		EnableTimer("execute_in_area_timer", true)

	end

	function execute_in_area_tick(name, line, wildcards)

		local localRoom = currentRoom
		local localState


		-- thread safety
		if (localRoom == nil) then
			DebugNote("Unknown Room")
			return
		end
		
		if (char_status == nill) then
			DebugNote("Unknown char status")
			return
		else
			localState = tonumber(char_status.state)
		end

		local isActive = false
		
		--tprint(execute_in_area_array)

		for index, value in pairs(execute_in_area_array) do
		
			DebugNote("loop - " .. index)
			if (value.active == true) then
		
				value.index = value.index + 1

				if (value.index > 100) then
					value.active = false
					print("** aborting quickwhere timer for " .. index .. ", took too long to get to destination")
					
				else

					DebugNote("state:" .. localState .. ",:" .. value.areaId .. "==" .. localRoom.areaid)

					if ((localState == 3 and value.lastState == 3) 
						and value.areaId == localRoom.areaid) then

						-- skip first timer tick
						value.index = value.index + 1
						value.standIndex = value.standIndex + 1
						if (value.standIndex < 2) then
							DebugNote("skip - index:" .. value.index)
						else
							DebugNote("executing - index:" .. value.index)
							value.func()
							value.active = false						
						end
					else
						-- still moving.. reset index
						value.standIndex = 0
					end
				end
			end
			
			value.lastState = localState
			
			if (value.active == true) then
				isActive = true
			end
			
		end
		
		-- no timer items active.. disable
		if (isActive == false) then
			DebugNote("disable timer")
			EnableTimer("execute_in_area_timer", false)
		end
	end

	----------- EXTERNAL CALLOUTS -----------------------------
	
	function remote_guess_mob_name(mobName, areaId, broadcast)

		DebugNote("remote_guess_mob_name call:" .. mobName .. ":" .. areaId)
	
		local rc, mobGuess, subMob = CallPlugin(
			search_destroy_id, 
			"IGuessMobNameBroadcast", 
			mobName,
			areaId)
			
		if (subMob ~= nil) then
			DebugNote(subMob)
		end
		
		DebugNote("remote_guess_mob_name return:" .. mobGuess)
		return mobGuess

	end


	------ Utils ------

	function padRight(text, length, padChar)

		local padding = length - string.len(text)
		for i = 1, padding do
			text = text .. padChar
		end

		return text
	end

	function sanitize_filename(str)
		str = string.gsub(str, "[^%w%s()_-]", "")
		return str
	end

	function quote(str)
		return "\""..str.."\""
	end

	function dbcheck(code)

		if code ~= sqlite3.OK and    -- no error
			code ~= sqlite3.ROW and   -- completed OK with another row of data
			code ~= sqlite3.DONE then -- completed OK, no more rows
			local err = db:errmsg ()  -- the rollback will change the error message
			db:exec("ROLLBACK")      -- rollback any transaction to unlock the database
			error (err, 2)            -- show error in caller's context
		end -- if

	end -- dbcheck

	function fixsql(s)

		if s then
			return "'" .. (string.gsub (s, "'", "''")) .. "'" -- replace single quotes with two lots of single quotes
		else
			return "NULL"
		end -- if
	end -- fixsql

	function fixbool(b)
		if b then
			return 1
		else
			return 0
		end -- if
	end -- fixbool

	function split(line, delim)

		local result = {}
		local index = 1

		for token in string.gmatch(line, delim) do
			result[index] = token
			index = index + 1
		end

		return result
	end

	function set_check_vidblain(name, line, wildcards)

	  if (USER_check_vidblain == "true") then
		USER_check_vidblain = "false"
	  else
		USER_check_vidblain = "true"
	  end

	  local msg = "off"
	  if (USER_check_vidblain == "true") then
		msg = "on"
	  end
	  ColourNote ("darkorange", "", "No-portal vidblain assistance: " .. msg)
	end

	function OnPluginSaveState()

		SetVariable("XRunToCheckVidblain", USER_check_vidblain)

	end

	--------- Sql Execution ------------

	function RunSql(name, line, wildcards)

		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))

		local index = 0
		local sql = wildcards.sql
		ColourNote("darkorange", "", "running :" .. sql)
		for row in db:nrows(sql) do
			index = index + 1
			print("----------- record " .. index .. " -----------" )
			tprint(row)
	--		print (serialize.save ("row", row))
		end
		
		db:close_vm()
	end

	function ExecSql (name, line, wildcards)
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))

		Note("executing " .. wildcards.sql)
	--	dbcheck (db:execute (fixsql(wildcards.sql)))
		db:execute(fixsql(wildcards.sql))

		db:close_vm()
		Note("ok")
	end

	-------------- DEBUG --------------------

	function ext_debug(name, line, wildcards)
		if (showDebug == 0) then
			showDebug = 1
		else
			showDebug = 0
		end
		Note("Ext debug:" .. showDebug)
	end	
	
	function DebugNote(text)
		if (showDebug == 1) then
			Note("Extender ~ " .. text)
		end
	end

	function DebugTPrint(title, obj)
		if (showDebug == 1) then
			DebugNote(title .. " : " .. serialize.save_simple(obj))
		end
	end


	-------------- INSTALL MESSAGE ------------------

	function InstallMessage()
		ColourNote("MediumSeaGreen", "", "+=======================================================+")
		ColourNote("MediumSeaGreen", "", "+ Extender Installed - type 'extender help' for options +")
		ColourNote("MediumSeaGreen", "", "+=======================================================+")
	end

	InstallMessage()


]]>
</script>

</muclient>


<!-- BUGS


-->
